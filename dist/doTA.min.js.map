{"version":3,"sources":["doTA.js"],"names":["doTA","T","m","e","g","a","indexOf","charAt","closeTag","substring","comment","c","f","l","b","p","d","u","h","n","slice","length","replace","toLowerCase","openTag","voidTag","text","console","error","U","V","toUpperCase","I","document","getElementById","substr","setAttribute","String","prototype","trim","this","Object","watch","unwatch","A","createElement","W","X","Y","Z","aa","ba","P","ca","da","F","D","O","diff","H","firstChild","nodeType","nodeValue","diff2","lastIndexOf","innerHTML","parentNode","replaceChild","insertBefore","createTextNode","appendChild","diff3","r","J","w","removeChild","getId","initCH","compile","match","C","push","G","R","loose","watchDiff","diffLevel","true","false","null","void","undefined","$index","S","$attr","K","M","N","Math","Date","Array","Infinity","NaN","var","in","B","x","Q","E","dotaRender","k","key","strip","encode",">","<","t","v","q","skip","L","y","z","refresh","elif","exec","style","model","bind","value","test","event","id","expand","join","params","optimize","debug","log","Function","PS","module","exports","noop","time","timeEnd"],"mappings":"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","file":"doTA.min.js","sourcesContent":["var doTA = (function() {'use strict';\n  // var msie = (typeof document !== 'undefined' && document.documentMode) ||\n  //   (typeof navigator !== 'undefined' && /Edge/.test(navigator.userAgent) && 12);\n\n  /* for ie8 */\n  if (!String.prototype.trim) {\n    String.prototype.trim = function() {\n      return this.replace(/^\\s+|\\s+$/g,'');\n    };\n  }\n\n  /* no, thanks! firefox */\n  if (Object.prototype.watch) {\n    delete Object.prototype.watch;\n    delete Object.prototype.unwatch;\n  }\n\n  // pretty indent for debugging\n  function indent(n, x) {\n    var ret = new Array(n + 2).join('    ');\n    return x ? ret.slice(0, -2 * x) : ret;\n  }\n\n  // decode html entities\n  function decodeEntities(text) {\n    return text.indexOf('&') < 0 ? text : text\n      .replace(/&gt;/g, '>').replace(/&lt;/g, '<')\n      .replace(/&amp;/g, '&').replace(/&quot;/g, '\"');\n  }\n\n  // parse attributes from html open tag and make dict object\n  function parseAttr(chunk, func) {\n    var attr = {}, tagName;\n    var pos = chunk.indexOf(' ');\n    var spPos;\n    var len, attrName, attrVal;\n    var valStart, valEndPos;\n\n    if (pos !== -1) {\n      tagName = chunk.slice(0, pos);\n      len = chunk.length;\n\n      //console.log(222, [pos, chunk]);\n      while (++pos < len) {\n        var eqPos = chunk.indexOf('=', pos);\n        // console.log('chunk', [chunk, pos, eqPos, chunk.slice(pos)]);\n\n        // ** attribute without value (last attribute) **\n        if (eqPos === -1) {\n          do {\n            spPos = chunk.indexOf(' ', pos);\n            if (spPos > 0) {\n              attrName = chunk.slice(pos, spPos);\n            } else {\n              attrName = chunk.slice(pos);\n            }\n            // console.log('eqPos === -1', [attrName, pos, chunk])\n            if (attrName !== '/') {\n              attr[attrName] = '';\n            }\n            pos = spPos + 1;\n\n          } while (spPos > 0);\n          //attr required will be required=\"\", while is valid syntax\n          //http://www.w3.org/TR/html-markup/syntax.html#syntax-attr-empty\n          break;\n        }\n\n\n        spPos = chunk.indexOf(' ', pos);\n        // console.log('chunk', [chunk, eqPos, pos, spPos, chunk.slice(pos, spPos)]);\n\n        if (spPos > 0 && spPos < eqPos) {\n          attr[chunk.slice(pos, spPos)] = \"\";\n          pos = spPos;\n          continue;\n        }\n\n        //console.log(33, [eqPos]);\n        attrName = chunk.slice(pos, eqPos);\n        //console.log(331, [attrName]);\n\n        valStart = chunk[eqPos + 1];\n        //console.log(332, [valStart]);\n\n        //if attribute value is start with quote\n        if (valStart === '\"' || valStart === \"'\") {\n          valEndPos = chunk.indexOf(valStart, eqPos + 2);\n          if (valEndPos < 0) { throw 'ERR:Invalid HTML: [' + chunk + ']'; }\n\n          attrVal =  chunk.slice(eqPos + 2, valEndPos);\n          attr[attrName] =0>attrVal.indexOf(\"&\")?attrVal:attrVal.replace(/&gt;/g,\">\").replace(/&lt;/g,\"<\").replace(/&amp;/g,\"&\").replace(/&quot;/g,'\"'); //INLINE;\n          pos = valEndPos + 1;\n          //console.log(311, [valEndPos, attrName, attrVal]);\n        } else {\n\n          valEndPos = chunk.indexOf(' ', eqPos + 2);\n\n          //when no more attributes\n          if (valEndPos < 0) {\n            attrVal =  chunk.slice(eqPos + 1);\n            attr[attrName] =0>attrVal.indexOf(\"&\")?attrVal:attrVal.replace(/&gt;/g,\">\").replace(/&lt;/g,\"<\").replace(/&amp;/g,\"&\").replace(/&quot;/g,'\"'); //INLINE;\n            //console.log(442, [attrVal]);\n            break;\n\n          } else {\n            attrVal =  chunk.slice(eqPos + 1, valEndPos);\n            attr[attrName] =0>attrVal.indexOf(\"&\")?attrVal:attrVal.replace(/&gt;/g,\">\").replace(/&lt;/g,\"<\").replace(/&amp;/g,\"&\").replace(/&quot;/g,'\"'); //INLINE;\n            //console.log(313, [eqPos, valEndPos, attrVal]);\n            pos = valEndPos;\n          }\n        }\n      }\n\n      tagName = tagName.toLowerCase();\n      if (tagName === 'input' || tagName === 'img') {\n        //http://www.w3.org/TR/html-markup/syntax.html\n        //area, base, br, col, command, embed, hr, img, input, keygen, link, meta, param, source, track, wbr\n        func.openTag(tagName, attr, 1);\n        func.voidTag();\n      } else if (attrName === '/') {\n        func.openTag(tagName, attr);\n        func.closeTag(tagName);\n      } else {\n        func.openTag(tagName, attr);\n      }\n\n    // no attributes\n    } else {\n\n      // self closing, explicit\n      if (chunk.charAt(chunk.length - 1) === '/') {\n        tagName = chunk.slice(0, -1).toLowerCase();\n\n        if (tagName === 'br' || tagName === 'hr') {\n          func.openTag(tagName, attr, 1);\n          func.voidTag();\n        } else {\n          func.openTag(tagName, attr);\n          func.closeTag(tagName);\n        }\n      } else {\n        tagName = chunk.toLowerCase();\n\n        // self closing, implicit\n        if (tagName === 'br' || tagName === 'hr') {\n          func.openTag(tagName, attr, 1);\n          func.voidTag();\n        } else {\n          func.openTag(tagName, attr);\n        }\n      }\n    }\n\n  }\n\n  var events = ' scroll change click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste ';\n  var valid_chr = '_$abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n\n  // minimal stripped down html parser\n  function parseHTML(html, func) {\n    if (!html) { return; }\n    var prevPos = 0, pos = html.indexOf('<');\n    do {\n      if (html.charAt(pos) === '<') {\n        pos++;\n        if (html.charAt(pos) === '/') {\n          prevPos = ++pos;\n          pos = html.indexOf('>', prevPos);\n          //close tag must be like </div>, but not <div />\n          // console.log(['closetag', prevPos, pos, html.substring(prevPos, pos)])\n          func.closeTag(html.substring(prevPos, pos));\n        } else if (html.charAt(pos) === '!') {\n          prevPos = pos;\n          pos = html.indexOf('>', prevPos);\n          // console.log(['comment', prevPos, pos, html.substring(prevPos, pos)])\n          func.comment(html.substring(prevPos, pos));\n        } else {\n          prevPos = pos;\n          pos = html.indexOf('>', prevPos);\n          // console.log(['opentag', prevPos, pos, html.substring(prevPos, pos), parseAttr(html.substring(prevPos, pos))])\n          // func.openTag.apply(this, parseAttr(html.substring(prevPos, pos)));\n          parseAttr(html.substring(prevPos, pos), func);\n        }\n      } else if (html.charAt(pos) === '>') { //&& html.charAt(pos + 1) !== '<'\n        prevPos = ++pos;\n        pos = html.indexOf('<', prevPos);\n        if (pos > prevPos) {\n          // console.log(['text', prevPos, pos, html.substring(prevPos, pos)])\n          func.text(html.substring(prevPos, pos));\n        }\n      } else {\n        if (prevPos === 0 && pos < 0 && html) {\n          func.text(html);\n        } else {\n          /** */console.error('Parse ERR?', [prevPos, pos, html, html.substring(prevPos, pos), html.slice(pos)]);\n        }\n        break;\n      }\n\n    } while (pos > 0);\n  }\n\n  //diff and patch dom with exact same structure\n  function diffPatchExact(prevKey, html2) {\n    var html1 = doTA.H[prevKey];\n    var prevPos1 = 0, pos1 = html1.indexOf('<');\n    var prevPos2 = 0, pos2 = html2.indexOf('<');\n    var tagId = '', elem, part1, part2;\n    var posx, endPosx;\n\n    do {\n      if (html1.charAt(pos1) === \"<\") {\n        pos1++;\n        pos2++;\n        if (html1.charAt(pos1) === \"/\" || html1.charAt(pos1) === \"!\") {\n          //don't patch comment node and close tag.\n          pos1 = html1.indexOf('>', pos1);\n          pos2 = html2.indexOf('>', pos2);\n        } else {\n          prevPos1 = pos1;\n          prevPos2 = pos2;\n          pos1 = html1.indexOf('>', prevPos1);\n          pos2 = html2.indexOf('>', prevPos2);\n          part1 = html1.substring(prevPos1, pos1);\n          part2 = html2.substring(prevPos2, pos2);\n          //attributes\n          if (part1 !== part2) {\n            // console.log('openTag', [part1, part2])\n            tagId = parsePatchAttr(part1, part2);\n          } else {\n            //record id\n            //tagId = getTagId(part1);\n            posx = part1.indexOf(' id=\"');\n            0 <= posx && (posx += 5, endPosx = part1.indexOf('\"', posx), tagId = part1.substring(posx, endPosx));\n          }\n        }\n\n      //text node\n      } else if (html1.charAt(pos1) === '>') {\n        prevPos1 = ++pos1;\n        prevPos2 = ++pos2;\n\n        pos1 = html1.indexOf('<', prevPos1);\n        pos2 = html2.indexOf('<', prevPos2);\n        //textNode, only support firstChild here\n        if (pos2 > prevPos2) {\n          var text1 = html1.substring(prevPos1, pos1);\n          var text2 = html2.substring(prevPos2, pos2);\n          if (text1 !== text2) {\n            elem = document.getElementById(tagId);\n            if (elem) {\n              if (elem.firstChild && elem.firstChild.nodeType === 3) {\n                // console.log('textApplied', [text1, text2]);\n                elem.firstChild.nodeValue = text2;\n              } //else to log something?\n            } else {\n              console.log('tag not found', [tagId]);\n            }\n          }\n        }\n\n      }\n\n    } while(pos1 > 0);\n  }\n\n  // find position of outerHTML end\n  // this function will be inline during building\n  function getOuterHTMLEnd(HTML, START_POS) {\n    var LVL = 1, POS = START_POS;\n    for(;;) {\n      POS = HTML.indexOf('>', POS);\n      if (HTML.charAt(POS - 1) === '/') { //self closing\n        LVL--;\n        if (LVL <= 0) break;\n      }\n      POS = HTML.indexOf('<', POS);\n      if (HTML.charAt(POS + 1) === '/') {\n        LVL--;\n        if (LVL <= 0) {\n          POS = HTML.indexOf('>', POS + 2);\n          break;\n        }\n      } else if (HTML.charAt(POS + 1) !== '!') {\n        LVL++;\n      }\n      // console.log('LVL', LVL);\n    }\n\n    // console.log('getOutHTML', tagName, [tagName, pos2, pos2, ])\n    return ++POS;\n  }\n\n  //less memory usage with this, javascript is single threaded anyway\n  var newNode = typeof document !== 'undefined' && document.createElement('div');\n\n  // FlatDOM: diff html as text and patch dom nodes\n  function diff2(prevKey, html2) {\n    var html1 = doTA.H[prevKey];\n    var prevPos1 = 0, pos1 = html1.indexOf('<');\n    var prevPos2 = 0, pos2 = html2.indexOf('<');\n    var tagId1, tagId2, elem1, part1, part2;\n    // var tagNo1 = 0, tagNo2 = 0;\n    var tagStartPos1, tagStartPos2;\n    var LVL; //this is needed for fnInline\n    // console.log(html1);\n    // console.log(html2);\n\n    for (;;) {\n      // console.log('before', [dirty1, dirty2], [tagId1, tagId2], [html1.substr(pos1, 20), html2.substr(pos2, 20)]);\n\n      if (pos1 >= 0) {\n        pos1 = html1.indexOf(' id=\"', pos1);\n        if (pos1 > 0) {\n          prevPos1 = pos1 + 5;\n          pos1 = html1.indexOf('\"', prevPos1);\n          tagId1 = html1.substring(prevPos1, pos1);\n          // tagNo1 = tagId1^0;\n        }\n      }\n\n      // console.log('middle', [tagId1, tagId2], [html1.substr(pos1, 20), html2.substr(pos2, 20)]);\n\n      if (pos2 >= 0) {\n        pos2 = html2.indexOf(' id=\"', pos2);\n        if (pos2 > 0) {\n          prevPos2 = pos2 + 5;\n          pos2 = html2.indexOf('\"', prevPos2);\n          tagId2 = html2.substring(prevPos2, pos2);\n          // tagNo2 = tagId2^0;\n        }\n      }\n\n      // console.log('after', [dirty1, dirty2], [tagId1, tagId2],\n      //   [pos1, pos2], [html1.substr(pos1, 20), html2.substr(pos2, 20)]);\n\n      //exist inifite loop\n      if (pos1 < 0 || pos2 < 0) break;\n\n      //same node\n      if (tagId1 === tagId2) {\n        tagStartPos1 = ++pos1;\n        pos1 = html1.indexOf('>', pos1);\n        part1 = html1.substring(tagStartPos1, pos1);\n\n        tagStartPos2 = ++pos2;\n        pos2 = html2.indexOf('>', pos2);\n        part2 = html2.substring(tagStartPos2, pos2);\n\n        // console.log('same node', [part1, part2]);\n\n        //attr really different\n        if (part1 !== part2) {\n          elem1 = document.getElementById(tagId1);\n          if (elem1) {\n            //nodes to be inserted or deleted\n            if ((part1.substr(1, 6) === 'hidden') !== (part2.substr(1, 6) === 'hidden')) {\n              tagStartPos2 = html2.lastIndexOf('<', pos2 - 6);\n              LVL=1,pos2=tagStartPos2;for(;;){pos2=html2.indexOf(\">\",pos2);if(\"/\"===html2.charAt(pos2-1)&&(LVL--,0>=LVL))break;pos2=html2.indexOf(\"<\",pos2);if(\"/\"===html2.charAt(pos2+1)){if(LVL--,0>=LVL){pos2=html2.indexOf(\">\",pos2+2);break}}else\"!\"!==html2.charAt(pos2+1)&&LVL++}pos2++; //INLINE\n              newNode.innerHTML = html2.substring(tagStartPos2, pos2);\n\n              // tagStartPos1 = html1.lastIndexOf('<', pos1 - 6);\n              // console.warn('replaceChild', [tagId2, tagId1], [\n              //   html2.substring(tagStartPos2, getOuterHTMLEnd(html2, tagStartPos2)),\n              //   html1.substring(tagStartPos1, getOuterHTMLEnd(html1, pos1))]);\n\n              elem1.parentNode.replaceChild(newNode.firstChild, elem1);\n\n              LVL=1,pos1=pos1;for(;;){pos1=html1.indexOf(\">\",pos1);if(\"/\"===html1.charAt(pos1-1)&&(LVL--,0>=LVL))break;pos1=html1.indexOf(\"<\",pos1);if(\"/\"===html1.charAt(pos1+1)){if(LVL--,0>=LVL){pos1=html1.indexOf(\">\",pos1+2);break}}else\"!\"!==html1.charAt(pos1+1)&&LVL++}pos1++; //INLINE\n\n            //only attribute changes\n            } else {\n              parsePatchAttr(part1, part2, elem1);\n              // console.warn('patch node', [tagId1, tagId2], [pos1, pos2], [tagStartPos1, tagStartPos2], [part1, part2])\n            }\n          } else {\n            console.error('elem not found', [tagId1, tagId2], [part1, part2]);\n            return;\n          }\n        } else {\n          //clear node for textNode\n          elem1 = void 0;\n        }\n\n        //if blank text node, skip early\n        if (html1.charAt(pos1 + 1) === '<' && html2.charAt(pos2 + 1) === '<') {\n          pos1++;\n          pos2++;\n          continue;\n        }\n\n        prevPos1 = pos1;\n        pos1 = html1.indexOf('<', prevPos1);\n        part1 = html1.substring(prevPos1 + 1, pos1);\n        prevPos2 = pos2;\n        pos2 = html2.indexOf('<', prevPos2);\n        part2 = html2.substring(prevPos2 + 1, pos2);\n\n        //for text node really diff\n        if (part1 !== part2) {\n          // console.log('text diff', [tagId1, tagId2], [part1, part2]);\n          if (!elem1) {\n            elem1 = document.getElementById(tagId1);\n            if (!elem1) {\n              console.error('node not found', [tagId1, tagId2], [part1, part2], [html1.substr(pos1, 15), html2.substr(pos2, 15)], [html1, html2]);\n              return;\n            }\n          }\n          // console.log('part1,2', [part1, part2]);\n          if (elem1.firstChild) {\n            //overwrite textNode value\n            if (elem1.firstChild.nodeType === 3) {\n              elem1.firstChild.nodeValue = part2;\n              // console.warn('textNode overwritten', elem1, elem1.firstChild)\n\n            //not textNode, so, insertBefore\n            } else {\n              elem1.insertBefore(document.createTextNode(part2), elem1.firstChild);\n              // console.warn('textNode inserted', elem1, elem1.firstChild)\n            }\n\n          //no childNodes, so append one\n          } else {\n            elem1.appendChild(document.createTextNode(part2));\n          }\n        }\n      } else {\n        console.error(\"different Id - not supported for now!\", [tagId1, tagId2]);\n        return;\n      }\n\n    } //infinite loop\n\n  }\n\n  // diff3: no place holder nodes\n  function diff3(prevKey, html2) {\n    var html1 = doTA.H[prevKey];\n    var part1, part2, elem1;\n    var prevPos1, lastPos1, pos1 = html1.indexOf('<');\n    var prevPos2, lastPos2, pos2 = html2.indexOf('<');\n    var tagId1, tagId2, prevTagId1, prevTagId2;\n    var tagNo1, tagNo2, subNo1, subNo2, dotPos1, dotPos2;\n    var tagStartPos1, tagStartPos2;\n    var LVL; //this is needed for fnInline\n    // console.log(html1);\n    // console.log(html2);\n    // var logger = [];\n\n    for (;;) {\n      // console.log('before', [dirty1, dirty2], [tagId1, tagId2], [html1.substr(pos1, 20), html2.substr(pos2, 20)]);\n\n      if (pos1 >= 0) {\n        lastPos1 = pos1;\n        pos1 = html1.indexOf(' id=\"', pos1);\n        if (pos1 > 0) {\n          prevPos1 = pos1 + 5;\n          pos1 = html1.indexOf('\"', prevPos1);\n          prevTagId1 = tagId1;\n          tagId1 = html1.substring(prevPos1, pos1);\n        }\n      }\n\n      // console.log('middle', [tagId1, tagId2], [html1.substr(pos1, 20), html2.substr(pos2, 20)]);\n\n      if (pos2 >= 0) {\n        lastPos2 = pos2;\n        pos2 = html2.indexOf(' id=\"', pos2);\n        if (pos2 > 0) {\n          prevPos2 = pos2 + 5;\n          pos2 = html2.indexOf('\"', prevPos2);\n          prevTagId2 = tagId2;\n          tagId2 = html2.substring(prevPos2, pos2);\n        }\n      }\n\n      // console.log('after', [dirty1, dirty2], [tagId1, tagId2],\n      //   [pos1, pos2], [html1.substr(pos1, 20), html2.substr(pos2, 20)]);\n\n      //exist infinite loop\n      if (pos1 < 0 && pos2 < 0) break;\n\n      //same node\n      if (tagId1 === tagId2) {\n        tagStartPos1 = ++pos1;\n        pos1 = html1.indexOf('>', pos1);\n        part1 = html1.substring(tagStartPos1, pos1);\n\n        tagStartPos2 = ++pos2;\n        pos2 = html2.indexOf('>', pos2);\n        part2 = html2.substring(tagStartPos2, pos2);\n\n        // console.log('same node', [part1, part2]);\n\n        //attr really different\n        if (part1 !== part2) {\n          elem1 = document.getElementById(tagId1);\n          if (elem1) {\n            //nodes to be inserted or deleted\n            if ((part1.substr(1, 6) === 'hidden') !== (part2.substr(1, 6) === 'hidden')) {\n              tagStartPos2 = html2.lastIndexOf('<', pos2 - 6);\n              LVL=1,pos2=tagStartPos2;for(;;){pos2=html2.indexOf(\">\",pos2);if(\"/\"===html2.charAt(pos2-1)&&(LVL--,0>=LVL))break;pos2=html2.indexOf(\"<\",pos2);if(\"/\"===html2.charAt(pos2+1)){if(LVL--,0>=LVL){pos2=html2.indexOf(\">\",pos2+2);break}}else\"!\"!==html2.charAt(pos2+1)&&LVL++}pos2++; //INLINE\n              newNode.innerHTML = html2.substring(tagStartPos2, pos2);\n\n              // tagStartPos1 = html1.lastIndexOf('<', pos1 - 6);\n              // console.warn('replaceChild', [tagId2, tagId1], [\n              //   html2.substring(tagStartPos2, getOuterHTMLEnd(html2, tagStartPos2)),\n              //   html1.substring(tagStartPos1, getOuterHTMLEnd(html1, pos1))]);\n\n              elem1.parentNode.replaceChild(newNode.firstChild, elem1);\n\n              LVL=1,pos1=pos1;for(;;){pos1=html1.indexOf(\">\",pos1);if(\"/\"===html1.charAt(pos1-1)&&(LVL--,0>=LVL))break;pos1=html1.indexOf(\"<\",pos1);if(\"/\"===html1.charAt(pos1+1)){if(LVL--,0>=LVL){pos1=html1.indexOf(\">\",pos1+2);break}}else\"!\"!==html1.charAt(pos1+1)&&LVL++}pos1++; //INLINE\n\n            //only attribute changes\n            } else {\n              parsePatchAttr(part1, part2, elem1);\n              // console.warn('patch node', [tagId1, tagId2], [pos1, pos2], [tagStartPos1, tagStartPos2], [part1, part2])\n            }\n          } else {\n            console.error('elem not found', [tagId1, tagId2], [part1, part2]);\n            return;\n          }\n        } else {\n          //clear node for textNode\n          elem1 = void 0;\n        }\n\n        //if blank text node, skip early\n        if (html1.charAt(pos1 + 1) === '<' && html2.charAt(pos2 + 1) === '<') {\n          pos1++;\n          pos2++;\n          continue;\n        }\n\n        prevPos1 = pos1;\n        pos1 = html1.indexOf('<', prevPos1);\n        part1 = html1.substring(prevPos1 + 1, pos1);\n        prevPos2 = pos2;\n        pos2 = html2.indexOf('<', prevPos2);\n        part2 = html2.substring(prevPos2 + 1, pos2);\n\n        //for text node really diff\n        if (part1 !== part2) {\n          // console.log('text diff', [tagId1, tagId2], [part1, part2]);\n          if (!elem1) {\n            elem1 = document.getElementById(tagId1);\n            if (!elem1) {\n              console.error('node not found', [tagId1, tagId2], [part1, part2], [html1.substr(pos1, 15), html2.substr(pos2, 15)], [html1, html2]);\n              return;\n            }\n          }\n          // console.log('part1,2', [part1, part2]);\n          if (elem1.firstChild) {\n            //overwrite textNode value\n            if (elem1.firstChild.nodeType === 3) {\n              elem1.firstChild.nodeValue = part2;\n              // console.warn('textNode overwritten', elem1, elem1.firstChild)\n\n            //not textNode, so, insertBefore\n            } else {\n              elem1.insertBefore(document.createTextNode(part2), elem1.firstChild);\n              // console.warn('textNode inserted', elem1, elem1.firstChild)\n            }\n\n          //no childNodes, so append one\n          } else {\n            elem1.appendChild(document.createTextNode(part2));\n          }\n        }\n\n\n      //when id is different\n      } else {\n\n        dotPos1 = tagId1.indexOf('.');\n        tagNo1 = tagId1.slice(0, dotPos1) ^ 0;\n        dotPos2 = tagId1.indexOf('.', ++dotPos1);\n        subNo1 = dotPos2 > 0 && tagId1.slice(dotPos1, dotPos2) ^ 0;\n\n        dotPos2 = tagId2.indexOf('.');\n        tagNo2 = tagId2.slice(0, dotPos2) ^ 0;\n        dotPos1 = tagId2.indexOf('.', ++dotPos2);\n        subNo2 = dotPos1 > 0 && tagId2.slice(dotPos2, dotPos1) ^ 0;\n\n        if (prevTagId1 === prevTagId2 && pos1 > 0 && pos2 > 0) {\n\n          //[\"6.1\", \"5.7.1\"] [\"5.6.1\", \"5.6.1\"]\n          if (tagNo1 > tagNo2) {\n            elem1 = document.getElementById(prevTagId2);\n            if (!elem1) {\n              console.warn([\"no existing node 5\", [tagId1, tagId2], [prevTagId1, prevTagId2], [pos1, pos2]]);\n            } else {\n              tagStartPos2 = html2.lastIndexOf('<', pos2 - 6);\n              LVL=1,pos2=tagStartPos2;for(;;){pos2=html2.indexOf(\">\",pos2);if(\"/\"===html2.charAt(pos2-1)&&(LVL--,0>=LVL))break;pos2=html2.indexOf(\"<\",pos2);if(\"/\"===html2.charAt(pos2+1)){if(LVL--,0>=LVL){pos2=html2.indexOf(\">\",pos2+2);break}}else\"!\"!==html2.charAt(pos2+1)&&LVL++}pos2++; //INLINE\n              newNode.innerHTML = html2.substring(tagStartPos2, pos2);\n\n              //huge scroll - hack\n              if (tagId2.length - prevTagId2.length >= 2) {\n                elem1.appendChild(newNode.firstChild);\n                // logger.push([\"this.appendChild\", [tagId1, tagId2], [prevTagId1, prevTagId2], [html2.substring(tagStartPos2, pos2)]]);\n              } else {\n                elem1.parentNode.appendChild(newNode.firstChild);\n                // logger.push([\"parent.appendChild[first]\", [tagId1, tagId2], [prevTagId1, prevTagId2], [html2.substring(tagStartPos2, pos2)]]);\n              }\n              pos1 = lastPos1;\n              tagId1 = prevTagId1;\n              tagId2 = prevTagId2;\n              continue;\n            }\n\n          // [5, 6] [24, false] [\"5.24.1\", \"6.1\"] [\"5.23.1\", \"5.23.1\"] [673, 770]\n          } else if (tagNo1 < tagNo2) {\n            elem1 = document.getElementById(tagId1);\n            if (!elem1) {\n              console.warn([\"no existing node 4\", [tagId1, tagId2], [prevTagId1, prevTagId2], [pos1, pos2]]);\n            } else {\n              elem1.parentNode.removeChild(elem1);\n              if (pos1 > 0) {\n                LVL=1,pos1=pos1;for(;;){pos1=html1.indexOf(\">\",pos1);if(\"/\"===html1.charAt(pos1-1)&&(LVL--,0>=LVL))break;pos1=html1.indexOf(\"<\",pos1);if(\"/\"===html1.charAt(pos1+1)){if(LVL--,0>=LVL){pos1=html1.indexOf(\">\",pos1+2);break}}else\"!\"!==html1.charAt(pos1+1)&&LVL++}pos1++; //INLINE\n              }\n              // logger.push([\"removeChild[first]\", tagId1, [tagId1, tagId2], [prevTagId1, prevTagId2], [html2.substring(tagStartPos2, pos2)]]);\n              pos2 = lastPos2;\n              tagId1 = prevTagId1;\n              tagId2 = prevTagId2;\n              continue;\n            }\n          }\n\n\n\n          //same level\n          if (tagNo1 === tagNo2) {\n\n            // [5, 5] [1, 2] [\"5.1.1\", \"5.2.1\"] [\"5.1\", \"5.1\"] [229, 227]\n            if ( subNo1 < subNo2 ) {\n              elem1 = document.getElementById(tagId1);\n              if (!elem1) {\n                console.warn([\"no existing node 4\", [tagId1, tagId2], [prevTagId1, prevTagId2], [pos1, pos2]]);\n              } else {\n                elem1.parentNode.removeChild(elem1);\n                if (pos1 > 0) {\n                  LVL=1,pos1=pos1;for(;;){pos1=html1.indexOf(\">\",pos1);if(\"/\"===html1.charAt(pos1-1)&&(LVL--,0>=LVL))break;pos1=html1.indexOf(\"<\",pos1);if(\"/\"===html1.charAt(pos1+1)){if(LVL--,0>=LVL){pos1=html1.indexOf(\">\",pos1+2);break}}else\"!\"!==html1.charAt(pos1+1)&&LVL++}pos1++; //INLINE\n                }\n                // logger.push([\"removeChild[backward.last]\", tagId1, [tagId1, tagId2], [prevTagId1, prevTagId2], [html2.substring(tagStartPos2, pos2)]]);\n                pos2 = lastPos2;\n                tagId1 = prevTagId1;\n                tagId2 = prevTagId2;\n                continue;\n              }\n\n            //[5, 5] [19, 18] [\"5.19.1\", \"5.18.1\"] [\"5.1\", \"5.1\"] [229, 231]\n            } else if ( subNo1 > subNo2 ) {\n              elem1 = document.getElementById(tagId1);\n\n              tagStartPos2 = html2.lastIndexOf('<', pos2 - 6);\n              LVL=1,pos2=tagStartPos2;for(;;){pos2=html2.indexOf(\">\",pos2);if(\"/\"===html2.charAt(pos2-1)&&(LVL--,0>=LVL))break;pos2=html2.indexOf(\"<\",pos2);if(\"/\"===html2.charAt(pos2+1)){if(LVL--,0>=LVL){pos2=html2.indexOf(\">\",pos2+2);break}}else\"!\"!==html2.charAt(pos2+1)&&LVL++}pos2++; //INLINE\n              newNode.innerHTML = html2.substring(tagStartPos2, pos2);\n\n              elem1.parentNode.insertBefore(newNode.firstChild, elem1);\n              // logger.push([\"this.insertBefore[elem1]\", [tagId1, tagId2], [prevTagId1, prevTagId2], [pos1, pos2], [html2.substring(tagStartPos2, pos2)]]);\n\n              pos1 = lastPos1;\n              tagId1 = prevTagId1;\n              tagId2 = prevTagId2; //check later\n              continue;\n            }\n\n          } //same parent\n\n        } //prevTagId1 === prevTagId2\n\n\n\n        //end of previous html\n        else if (pos1 < 0) {\n\n          // [\"28.9.1\", \"28.10.1\"] [\"28.8.1\", \"28.9.1\"] [-1, 16911]\n          if ( tagNo1 === tagNo2 && subNo1 < subNo2 ) {\n            elem1 = document.getElementById(prevTagId2);\n\n            tagStartPos2 = html2.lastIndexOf('<', pos2 - 6);\n            LVL=1,pos2=tagStartPos2;for(;;){pos2=html2.indexOf(\">\",pos2);if(\"/\"===html2.charAt(pos2-1)&&(LVL--,0>=LVL))break;pos2=html2.indexOf(\"<\",pos2);if(\"/\"===html2.charAt(pos2+1)){if(LVL--,0>=LVL){pos2=html2.indexOf(\">\",pos2+2);break}}else\"!\"!==html2.charAt(pos2+1)&&LVL++}pos2++; //INLINE\n            newNode.innerHTML = html2.substring(tagStartPos2, pos2);\n\n            //huge scroll - hack\n            if (tagId2.length - prevTagId2.length >= 2) {\n              elem1.appendChild(newNode.firstChild);\n              // logger.push([\"this.appendChild\", [tagId1, tagId2], [prevTagId1, prevTagId2], [html2.substring(tagStartPos2, pos2)]]);\n            } else {\n              elem1.parentNode.appendChild(newNode.firstChild);\n              // logger.push([\"appendChild[parent.last]1<0\", [tagId1, tagId2], [subNo1, subNo2], [prevTagId1, prevTagId2], [pos1, pos2], [html2.substring(tagStartPos2, pos2)]]);\n            }\n\n            tagId1 = prevTagId1;\n            tagId2 = prevTagId2;\n            continue;\n          } else {\n            console.warn('not impl1 pos1 < 0', [tagNo1, tagNo2], [subNo1, subNo2], [tagId1, tagId2], [prevTagId1, prevTagId2], [pos1, pos2], [html2.substring(tagStartPos2, pos2)]);\n          }\n        }\n\n\n        //end of new html\n        else if (pos2 < 0) {\n\n          //same base id\n          if (tagNo1 === tagNo2) {\n\n            // [28, 28] [undefined, 13] [\"28.1\", \"28.13.1\"] [\"28.1\", \"28.1\"] [-1, 12127]\n            if (subNo1 < subNo2) {\n              elem1 = document.getElementById(prevTagId2);\n\n              tagStartPos2 = html2.lastIndexOf('<', pos2 - 6);\n              LVL=1,pos2=tagStartPos2;for(;;){pos2=html2.indexOf(\">\",pos2);if(\"/\"===html2.charAt(pos2-1)&&(LVL--,0>=LVL))break;pos2=html2.indexOf(\"<\",pos2);if(\"/\"===html2.charAt(pos2+1)){if(LVL--,0>=LVL){pos2=html2.indexOf(\">\",pos2+2);break}}else\"!\"!==html2.charAt(pos2+1)&&LVL++}pos2++; //INLINE\n              newNode.innerHTML = html2.substring(tagStartPos2, pos2);\n\n              elem1.appendChild(newNode.firstChild);\n              // logger.push([\"appendChild[parent.last]2<0\", [tagId1, tagId2], [prevTagId1, prevTagId2], [pos1, pos2], [html2.substring(tagStartPos2, pos2)]]);\n\n              tagId1 = prevTagId1;\n              tagId2 = prevTagId2;\n              continue;\n\n            //[28, 28] [27, 26] [\"28.27.1\", \"28.26.1\"] [\"28.26.1\", \"28.25.1\"] [12548, -1]\n            } else if (subNo1 > subNo2) {\n\n              elem1 = document.getElementById(tagId1);\n              if (!elem1) {\n                console.warn([\"no existing node 4\", [tagId1, tagId2], [prevTagId1, prevTagId2], [pos1, pos2]]);\n              } else {\n                elem1.parentNode.removeChild(elem1);\n                if (pos1 > 0) {\n                  LVL=1,pos1=pos1;for(;;){pos1=html1.indexOf(\">\",pos1);if(\"/\"===html1.charAt(pos1-1)&&(LVL--,0>=LVL))break;pos1=html1.indexOf(\"<\",pos1);if(\"/\"===html1.charAt(pos1+1)){if(LVL--,0>=LVL){pos1=html1.indexOf(\">\",pos1+2);break}}else\"!\"!==html1.charAt(pos1+1)&&LVL++}pos1++; //INLINE\n                }\n                // logger.push([\"removeChild[backward.last]\", tagId1, [tagId1, tagId2], [prevTagId1, prevTagId2], [html2.substring(tagStartPos2, pos2)]]);\n\n                tagId1 = prevTagId1;\n                tagId2 = prevTagId2;\n                continue;\n              }\n\n            } else {\n              console.warn('not impl3 pos2 < 0', [tagNo1, tagNo2], [subNo1, subNo2], [tagId1, tagId2], [prevTagId1, prevTagId2], [pos1, pos2], [html2.substring(tagStartPos2, pos2)]);\n            }\n          }\n        }\n\n        ////////////// THIS SHOULD NEVER REACH ///////////////\n\n        // console.log('====')\n        // logger.slice(-10).forEach(function(item){\n        //   console.info.apply(console, item)\n        // })\n        console.error(\"different Id - not supported for now!\", [tagNo1, tagNo2], [subNo1, subNo2], [tagId1, tagId2], [prevTagId1, prevTagId2], [pos1, pos2]);\n        console.log([html1.substr(pos1 - 100, 100), html1.substr(pos1, 20)]);\n        console.log([html2.substr(pos2 - 100, 100), html2.substr(pos2, 20)]);\n        // console.log(html1);\n        // console.log(html2)\n        return;\n      }\n\n    } //infinite loop\n\n  }\n\n  var camelCaseRE = /-(.)/g;\n  function camelCase(str) {\n    return str.replace(camelCaseRE, function($0, $1){ return $1.toUpperCase(); });\n  }\n\n  // parse attributes from html open tag and patch DOM when different\n  function parsePatchAttr(chunkA, chunkB, elem) {\n    var tagId;\n    var posA1, posA2, posB1, posB2;\n    var posDiff = 0;\n    var attrName, attrVal1, attrVal2;\n    // var len1 = chunk1.length;\n    // console.log('chunks', [chunkA, chunkB]);\n\n    //extract id to tag, if no elem specified\n    if (!elem) {\n      posA1 = chunkA.indexOf(' id=\"', posA1);\n      if (posA1 >= 0) {\n        posA1 += 5;\n        posA2 = chunkA.indexOf('\"', posA1);\n        tagId = chunkA.slice(posA1, posA2);\n        elem = document.getElementById(tagId);\n        if (!elem) {\n          throw console.error('tag not found', [posA1, posA2, tagId, elem, chunkA, chunkB]);\n        }\n        posA2 += 2;\n      } else {\n        throw console.error('id not found', [posA1, posA1, chunkA, chunkB]);\n      }\n    } else {\n      //first char is always space\n      posA2 = 1;\n    }\n\n    for(;;) {\n      //attr name\n      posA1 = chunkA.indexOf('=\"', posA2);\n      if (posA1 < 0) break;\n      attrName = chunkA.slice(posA2, posA1);\n\n      //attr values\n      posA2 = chunkA.indexOf('\"', posA1 + 2);\n      attrVal1 =  chunkA.slice(posA1 + 2, posA2);\n\n      posB1 = posA1 + posDiff;\n      posB2 = chunkB.indexOf('\"', posB1 + 2);\n      attrVal2 =  chunkB.slice(posB1 + 2, posB2);\n\n      if (attrVal1 !== attrVal2) {\n        // value as property\n        if (attrName === 'value') {\n          elem[attrName] = attrVal2;\n\n        // prefix with - as property, like -scrollLeft\n        } else if (attrName.charAt(0) === '-') {\n          elem[attrName.substr(1)] = attrVal2;\n          // console.log('prop-', attrName.substr(1), attrVal2, elem[attrName.substr(1)]);\n\n        } else {\n            elem.setAttribute(attrName, attrVal2);\n        }\n        posDiff = posB2 - posA2;\n\n      }\n\n      posA2 += 2;\n    }\n\n    return tagId;\n  }\n\n  // extract value of id from part of html open tag\n  // only id=\"xxx\" supported, this is internal use, so it's always double-quotes\n  // inline this function during building\n  function getTagId(partial, start) {\n    var pos = partial.indexOf(' id=\"', start), endPos;\n    if (pos >= 0) {\n      pos += 5;\n      endPos = partial.indexOf('\"', pos);\n      return partial.substring(pos, endPos);\n    }\n  }\n\n  // split filters into array, take care of | and || as different\n  function splitFilters(input, pos) {\n    var prevPos = 0;\n    var ret = [];\n    while (pos !== -1) {\n      if (input.charAt(pos + 1) === '|') {\n        pos += 2;\n      } else {\n        ret.push(input.substring(prevPos, pos));\n        prevPos = ++pos;\n      }\n      pos = input.indexOf('|', pos);\n    }\n    if (prevPos < input.length) {\n      ret.push(input.substr(prevPos));\n    }\n    return ret;\n  }\n\n  function parseStyle(styleObj) {\n    var ret = '';\n    for (var x in styleObj) {\n      ret += x + ':' + styleObj[x] + ';';\n    }\n    return ret;\n  }\n\n  // ToDo: check compile performance with regex\n  var ngClassRegex = /('[^']+'|\"[^\"]+\"|[\\w$]+)\\s*:\\s*((?:[$.\\w]+|\\([^)]+\\)|[^},])+)/g;\n  var varOrStringRegex = /'[^']*'|\"[^\"]*\"|[\\w$]+|[^\\w$'\"]+/g;\n  var quotedStringRegex = /\"[^\"]*\"|'[^']*'/g;\n  var whiteSpaceRegex = /\\s{2,}|\\n/g;\n  var removeUnneededQuotesRegex = /\\b([\\w_-]+=)\"([^\"'\\s]+)\"(?=[\\s>])/g;\n  var lazyNgAttrRegex = /^(?:src|alt|title|href)/;\n  var $indexRegex = /\\$index/g;\n  var $parent$indexRegex = /(?:\\$parent\\.)+\\$index/g;\n\n  // no-val attributes, for more exhaustive list - https://github.com/kangax/html-minifier/issues/63\n  var noValAttrRegex = /^(?:checked|selected|disabled|readonly|multiple|required|hidden|nowrap)/;\n\n  // export as doTA.compile\n  function compileHTML(template, options) {\n    options = options || {};\n    var val_mod = options.loose ? \"||''\" : '';\n    var watchDiff = options.watchDiff;\n    var diffLevel = +options.diffLevel;\n    var VarMap = {\n      true: 1, false: 1, null: 1, void: 1, undefined: 1, this: 1,\n      doTA: 1, $index: 1, S: 1, F: 1, $attr: 1, X: 1, K: 1, M: 1, N: 1,\n      Math: 1, Date: 1, String: 1, Object: 1, Array: 1, Infinity: 1, NaN: 1,\n      // alert: 1, confirm: 1, prompt: 1,\n      var: 1, in: 1\n    };\n    var level = 0, ngRepeatLevel;\n    var ngIfLevel, skipLevel, ngIfCounterTmp, ngIfLevels = [], ngIfLevelMap = {};\n    var LevelMap = {}, LevelVarMap = {};\n    var KeyMap = [], keyLevel = 0;\n    var WatchMap = {}, Watched;\n    var doTAPass, doTAContinue;\n    var compiledFn;\n    var uniqueId = this.getId(options.dotaRender);\n    var idHash = {};\n    var FnText = '';\n\n    if (options.key) {\n      FnText += indent(level) + \"var R='';\\n\";\n    } else {\n      FnText += indent(level) + \"'use strict';var \" +\n      (watchDiff ? 'M,N=1,' : '') +\n      \"R='';\\n\"; //ToDO: check performance on var declaration\n    }\n\n    //clean up extra white spaces and line break\n    template = template.replace(whiteSpaceRegex, ' ');\n\n    if (options.strip) {\n      template = template.replace(/>\\s+/g, '>').replace(/\\s+</g, '<');\n    }\n\n    // when encode is set, find strings and encode < and >, or parser will throw error.\n    if (options.encode) {\n      template = template.replace(quotedStringRegex, function($0) {\n        return $0.replace(/[<>]/g, function($00) {\n          return {'>': '&gt;', '<': '&lt;'}[$00];\n        });\n      });\n    }\n\n    // attach plain variables to scope variables\n    function attachScope(v) {\n      //console.log(VarMap, [v]);\n      if (v) {\n        //var DEBUG = /error/.test(v);\n        //DEBUG && console.log(11, [v]);\n\n        //ToDo: still buggy, this need to improve\n        var vv = '';\n        var matches = v.match(varOrStringRegex);\n        //DEBUG && console.log(12, matches);\n        for(var i = 0; i < matches.length; i++) {\n\n          if (valid_chr.indexOf(matches[i].charAt(0)) >= 0 && !VarMap[matches[i]] &&\n            (!i || matches[i-1][matches[i-1].length-1] !== '.')) {\n            vv += 'S.' + matches[i];\n          } else {\n            if (matches[i].indexOf('$index') >= 0) {\n              //only support last level for now\n              vv += matches[i].replace($indexRegex, LevelVarMap[ngRepeatLevel]);\n            } else {\n              vv += matches[i];\n            }\n          }\n        }\n        //DEBUG && console.log(55, vv);\n        return vv;\n      }\n      return v;\n    }\n\n    // escape single quotes with backslash\n    function escapeSingleQuote(str) {\n      var quotePos = str.indexOf(\"'\");\n      if (quotePos >= 0) {\n        var ret = '';\n        var prevQuotePos = 0;\n        do {\n          ret += str.substring(prevQuotePos, quotePos);\n          //escaped quote\n          if (str.charAt(quotePos - 1) !== '\\\\') {\n            ret += \"\\\\\";\n          }\n          prevQuotePos = quotePos;\n          quotePos = str.indexOf(\"'\", prevQuotePos + 1);\n        } while (quotePos > 0);\n        ret += str.substr(prevQuotePos);\n        return ret;\n      } else {\n        return str;\n      }\n    }\n\n    // interpolation\n    function interpolate(str) {\n      var pos = str.indexOf('{{');\n      if (pos >= 0) {\n        var prevPos = 0;\n        var ret = '';\n        var outsideStr, insideStr;\n        do {\n          outsideStr = str.substring(prevPos, pos);\n          ret += escapeSingleQuote(outsideStr);\n\n          //skip {{\n          prevPos = pos + 2;\n          pos = str.indexOf('}}', prevPos);\n\n          insideStr = str.substring(prevPos, pos);\n          ret += \"'+(\" + attachFilter(insideStr) + val_mod + \")+'\";\n\n          //skip }} for next\n          prevPos = pos + 2;\n          pos = str.indexOf('{{', prevPos);\n        } while (pos > 0);\n\n        //remaining text outside interpolation\n        ret += escapeSingleQuote(str.substr(prevPos));\n        return ret;\n      } else {\n        return escapeSingleQuote(str);\n      }\n    }\n\n    // attach $filters\n    function attachFilter($1) {\n      //console.log(333,$1);\n      var pos = $1.indexOf('|');\n      if (pos === -1) {\n        return attachScope($1);\n      } else {\n        //ToDo: check this line later\n        var v = splitFilters($1, pos);\n        var val = attachScope(v[0]);\n        var prevColonPos, colonPos;\n        var filter;\n\n        //parse each filters\n        for(var i = 1; i < v.length; i++) {\n          filter = v[i];\n          prevColonPos = 0;\n\n          colonPos = filter.indexOf(':');\n          //filter with params\n          if (colonPos > 0) {\n            val = \"F('\" + filter.slice(prevColonPos, colonPos).trim() + \"')(\" + val;\n            prevColonPos = ++colonPos;\n            colonPos = filter.indexOf(':', prevColonPos);\n            while (colonPos > 0) {\n              val += ',' + attachScope(filter.slice(prevColonPos, colonPos));\n              prevColonPos = ++colonPos;\n              colonPos = filter.indexOf(':', prevColonPos);\n            }\n            val += ',' + attachScope(filter.substr(prevColonPos)) + ')';\n\n          //filter without params\n          } else {\n            val = \"F('\" + filter.trim() + \"')(\" + val + ')';\n          }\n\n        }\n        return val;\n      }\n    }\n\n    function apply$index(attrVal) {\n      var count, tmpRepeatLevel;\n\n      if (attrVal.indexOf('$parent.$index') >= 0) {\n        tmpRepeatLevel = ngRepeatLevel;\n        attrVal = attrVal.replace($parent$indexRegex, function($0) {\n          count = $0.match(/\\$parent/g).length; //may need to rewrite with indexOf\n          while (count>0) {\n            while (tmpRepeatLevel >= 0 && typeof LevelVarMap[--tmpRepeatLevel] === 'undefined') {}\n            --count;\n          }\n          return \"'+\" + LevelVarMap[tmpRepeatLevel] + \"+'\";\n        });\n      }\n      if (attrVal.indexOf('$index') >= 0) {\n        return attrVal.replace($indexRegex, \"'+\" + LevelVarMap[ngRepeatLevel] + \"+'\");\n      }\n      return attrVal;\n    }\n\n    //parse the element\n    parseHTML(template, {\n      //open tag with attributes\n      openTag: function(tagName, attr, selfClosing) {\n        // debug && console.log('openTag', [tagName, attr]);\n        var parsedAttr = {}, customId, tagId, noValAttr = '';\n        var attrName, attrVal, attrSkip, oneTimeBinding, doTAPassThis;\n\n        //skip parsing if dota-pass is specified (interpolation will still be expanded)\n        // https://jsperf.com/hasownproperty-vs-in-vs-undefined/12\n        if (typeof attr['dota-pass'] !== 'undefined') {\n          if (attr['dota-pass'] === 'this') {\n            doTAPass = doTAPassThis = 1;\n          } else {\n            doTAPass = level; doTAContinue = 0;\n          }\n        //re-enable dota parsing\n        } else if (typeof attr['dota-continue'] !== 'undefined') {\n          doTAContinue = level;\n        }\n\n        //unless dota-pass or with dota-continue\n        if (doTAPass === void 0 || doTAContinue) {\n\n          if (diffLevel === 2 && attr.skip) {\n            skipLevel = level;\n            attrSkip = attr.skip;\n            attr.skip = void 0;\n            FnText += indent(level, 1) + 'var O'+ level + '=N+' + attrSkip + '; \\n';\n          }\n\n          //ng-repeat to while/for loop\n          if (attr['ng-repeat']) {\n            //console.log(21,[x], [val]);\n            LevelMap[level] = LevelMap[level] ? LevelMap[level] + 1 : 1;\n            var idx = 'i' + level, l = 'l'+ level;\n            var NG_REPEAT = attr['ng-repeat'];\n            var inPos = NG_REPEAT.indexOf(' in ');\n            var repeatVar = NG_REPEAT.substr(0, inPos), repeatSrc = NG_REPEAT.substr(inPos + 4);\n            var commaPos = repeatVar.indexOf(',');\n            var pipePos = repeatSrc.indexOf('|'), repeatSrcNew;\n            var colonPos, x;\n\n            //store variable name to use for $index later\n            //this is ng-repeat specific, LevelMap[level] is same for ng-if too\n            LevelVarMap[level] = idx;\n            ngRepeatLevel = level;\n\n            if (pipePos > 0) {\n              repeatSrcNew = attachFilter(repeatSrc);\n            } else {\n              repeatSrcNew = attachScope(repeatSrc);\n              colonPos = repeatSrcNew.indexOf(':');\n            }\n\n            // Range: \"i in 1:10\" ==> (for i = 1; i < 10; i++)\n            if (colonPos >= 0) {\n              var start = repeatSrcNew.substr(0, colonPos) || 0, end, step;\n              var anotherColon = repeatSrcNew.indexOf(':', ++colonPos);\n              if (anotherColon > 0) {\n                end = repeatSrcNew.substring(colonPos, anotherColon);\n                step = repeatSrcNew.substr(anotherColon + 1);\n              } else {\n                end = repeatSrcNew.substr(colonPos);\n                step = 1;\n              }\n              // console.log([start, end, step, repeatSrcNew, colonPos]);\n\n              FnText += indent(level, 1) + 'for(var ' +\n                repeatVar + '=' + start + ';' +\n                repeatVar + (step > 0 ? '<' : '>') + end + ';' + repeatVar + '+=' + step + '){\\n';\n              VarMap[repeatVar] = 1;\n\n            // Object: \"k, v in {}\" ==> (for in {})\n            } else if (commaPos > 0) {\n              var key = repeatVar.substr(0, commaPos);\n              var value = repeatVar.substr(commaPos + 1);\n              FnText += indent(level, 1) + 'var ' +\n                value + ',D' + level + '=' + repeatSrcNew + ';\\n';\n              FnText += indent(level, 1) + 'for(var ' + key + ' in D' + level + '){\\n';\n              //                             space is needed for manual uglify  ->  vvv\n              FnText += indent(level) + value + ' = ' + 'D' + level + '[' + key + ']; \\n';\n              VarMap[key] = VarMap[value] = 1;\n\n            // Array: \"k in []\" ==> while loop\n            } else {\n              FnText += indent(level, 1) + 'var ' +\n                repeatVar + ',D' + level + '=' + repeatSrcNew + ','\n                + idx + '=-1,' + l + '=D' + level + '.length;\\n';\n              FnText += indent(level, 1) + 'while(++' + idx + '<' + l + '){\\n';\n              //                        space is needed for manual uglify  ->  vvv\n              FnText += indent(level) + repeatVar + '=D' + level + '[' + idx + ']; \\n';\n              VarMap[repeatVar] = 1;\n            }\n            //remote attribute not to get forwarded to angular\n            attr['ng-repeat'] = void 0;\n          }\n\n          if (diffLevel === 3 && attr.key) {\n            keyLevel = level;\n            KeyMap[level] = attr.key;\n            FnText += indent(level, 1) + 'var ' + attr.key + '=N,M=1; \\n';\n            attr.key = void 0;\n          }\n\n          //re-render sub template\n          if (attr.refresh) {\n            customId = 1;\n            oneTimeBinding = attr.refresh.indexOf('::');\n            FnText += indent(level, 2) +\n              (!Watched ? 'var ' + (watchDiff ? '': 'N=1,') + 'T=this;T.W=[];' : '') +\n              'var W={N:N,I:N+\"' + '.' + uniqueId + '\",W:\"' +\n              (oneTimeBinding >=0 ? attr.refresh.substr(oneTimeBinding + 2) + '\",O:1': attr.refresh + '\"') +\n              (attr.compile ? ',C:1' : '') +\n              '};T.W.push(W);\\n';\n            WatchMap[level] = Watched = 1;\n            FnText += indent(level, 2) + 'W.F=function(S,F,$attr,X,N){var R=\"\";\\n';\n            attr.refresh = void 0;\n          }\n\n          if (attr['ng-init']) {\n            var eqPos = attr[\"ng-init\"].indexOf('=');\n            if (eqPos > 0) {\n              var varName = attr[\"ng-init\"].substr(0, eqPos);\n              if (varName.indexOf('.') < 0 && varName.indexOf('[') < 0) {\n                FnText += indent(level) + 'var ' + varName + '=' +\n                  attachScope(attr[\"ng-init\"].substr(eqPos + 1)) + '; \\n';\n                VarMap[varName] = 1;\n              } else {\n                FnText += indent(level) + attachScope(attr[\"ng-init\"]) + '; \\n';\n              }\n            } else {\n              FnText += indent(level) + attachScope(attr[\"ng-init\"]) + '; \\n';\n            }\n            attr['ng-init'] = void 0;\n          }\n\n          //ng-if to javascript if\n          if (attr['ng-if']) {\n            if (diffLevel) {\n              ngIfLevel = level;\n              ngIfLevels.push(level);\n              ngIfLevelMap[level] = 0;\n            }\n            LevelMap[level] = LevelMap[level] ? LevelMap[level] + 1 : 1;\n            FnText += indent(level, 1) + 'if('+ attachScope(attr['ng-if']) +'){\\n';\n            // console.log('ng-if starts here', level);\n            attr['ng-if'] = void 0;\n          }\n\n          if (attr['elif']) {\n            FnText += indent(level, 1) + 'else if('+ attachScope(attr['elif']) +'){\\n';\n            LevelMap[level] = LevelMap[level] ? LevelMap[level] + 1 : 1;\n            attr['elif'] = void 0;\n          }\n\n          if (typeof attr['else'] !== 'undefined' && !watchDiff) {\n            FnText += indent(level, 1) + 'else{\\n';\n            LevelMap[level] = LevelMap[level] ? LevelMap[level] + 1 : 1;\n            attr['else'] = void 0;\n          }\n\n          //remove +''+ from class, for unnecessary string concat\n          if (attr.class) {\n            parsedAttr.class = interpolate(attr.class);\n            attr.class = void 0;\n          }\n\n          if (attr['ng-class']) {\n            var match;\n            var ngScopedClass = attachScope(attr['ng-class']);\n            parsedAttr.class = parsedAttr.class || '';\n            while((match = ngClassRegex.exec(ngScopedClass)) !== null) {\n              parsedAttr.class +=\n                (\"'+(\" + match[2] + '?' +\n                  \"'\" + (parsedAttr.class ? ' ' : '') + match[1].replace(/['\"]/g, '') +\n                  \"':'')+'\");\n            }\n            attr['ng-class'] = void 0;\n          }\n\n          if (attr['ng-show']) {\n            parsedAttr.class = parsedAttr.class || '';\n            parsedAttr.class += \"'+(\" + attachScope(attr['ng-show']) +\n              \"?'':'\" + (parsedAttr.class ? ' ' : '') + \"ng-hide')+'\";\n            attr['ng-show'] = void 0;\n          }\n\n          if (attr['ng-style']) {\n            parsedAttr.style = (attr.style ? attr.style + ';' : '') + interpolate(attr['ng-style']);\n              // \"'+doTA.PS(\" + interpolateInner(attr['ng-style']) + \")+'\";\n            attr['ng-style'] = void 0;\n            attr.style = void 0;\n          }\n\n          if (attr['ng-hide']) {\n            parsedAttr.class = parsedAttr.class || '';\n            parsedAttr.class += \"'+(\" + attachScope(attr['ng-hide']) +\n              \"?'\" + (parsedAttr.class ? ' ' : '') + \"ng-hide':'')+'\";\n            attr['ng-hide'] = void 0;\n          }\n\n          if (options.model && attr['ng-model']) {\n            if (attr['ng-model'].indexOf('$index') >= 0) {\n              parsedAttr['dota-model'] = apply$index(attr['ng-model']);\n            } else {\n              parsedAttr['dota-model'] = attr['ng-model'];\n            }\n            attr['ng-model'] = void 0;\n          }\n\n          if (options.bind && attr['ng-bind']) {\n            if (attr['ng-bind'].indexOf('$index') >= 0) {\n              parsedAttr['dota-bind'] = apply$index(attr['ng-bind']);\n            } else {\n              parsedAttr['dota-bind'] = attr['ng-bind'];\n            }\n            attr['ng-bind'] = void 0;\n          }\n\n          if (attr['ng-value']) {\n            parsedAttr.value = \"'+(\" + attachFilter(attr['ng-value']) + \")+'\";\n            attr['ng-value'] = void 0;\n          }\n\n          //some cleanup\n          if (parsedAttr.class) {\n            parsedAttr.class = parsedAttr.class.replace(/\\+''\\+/g, '+');\n          }\n\n          // expand interpolations on attributes, and some more\n          for (x in attr) {\n            attrVal = attr[x];\n            if (attrVal === void 0) { continue; }\n\n            // some ng- attributes\n            if (x.substr(0, 3) === 'ng-') {\n              //some ng-attr are just don't need it here.\n              attrName = x.substr(3);\n              //something like ng-src, ng-href, etc.\n              if (lazyNgAttrRegex.test(attrName)) {\n                x = attrName;\n\n              //convert ng-events to dota-events, to be bind later with native events\n              } else if (options.event && events.indexOf(' ' + attrName + ' ') >= 0) {\n                //add class 'de' for one time querying\n                if (parsedAttr.class) {\n                  if (parsedAttr.class.substr(0, 2) !== 'de') {\n                    parsedAttr.class = 'de ' + parsedAttr.class;\n                  }\n                } else {\n                  parsedAttr.class = 'de';\n                }\n                // parsedAttr.de = 1;\n                x = 'de-' + attrName;\n\n              } else if (noValAttrRegex.test(attrName)) {\n                noValAttr += \"'+(\" + attachScope(attrVal) + \"?' \" + attrName + \"=\\\"\\\"':'')+'\";\n                //noValAttr will attach later\n                continue;\n\n              }\n            } else if (x.charAt(0) === '-') {\n              x = '-' + camelCase(x.substr(1));\n              parsedAttr[x] = \"'+(\" + attachScope(attrVal) + \")+'\";\n              continue;\n            }\n\n            //ng-repeat loop variables are not available!\n            // only way to acccess is to use $index like \"data[$index]\"\n            // instead of \"item\" as in \"item in data\"\n            parsedAttr[x] = apply$index(interpolate(attrVal));\n          }\n\n        // pass all attributes to angular, except interpolation and $index\n        } else {\n          if (doTAPassThis) {\n            doTAPass = void 0;\n          }\n          //still expand interpolation even if dota-pass is set\n          for (x in attr) {\n            parsedAttr[x] = apply$index(interpolate(attr[x]));\n          }\n        }\n\n        //write tag back as string\n        FnText += indent(level) + \"R+='<\" + tagName;\n\n        //make id attr come before anything\n        if (customId || watchDiff) {\n          tagId = idHash[uniqueId + '.' + level] = parsedAttr.id || ( (\n            keyLevel < level && KeyMap[keyLevel] || options.key ?\n            \"'+\" + (options.key || KeyMap[keyLevel]) + \"+'.'+M+++'.\" :\n            \"'+N+++'.\"\n          ) + uniqueId);\n          FnText += ' id=\"' + tagId + '\"';\n          if (parsedAttr.id) {\n            parsedAttr.id = void 0;\n          }\n        }\n\n        //write back attributes\n        for(var k in parsedAttr) {\n          FnText += \" \" + k + '=\"' + parsedAttr[k] + '\"';\n        }\n\n        //attach boolean attributes at last\n        FnText += noValAttr +  (selfClosing ? ' /' : '') + \">';\\n\";\n\n        if (watchDiff) {\n          // FnText += indent(level) + \"N++; \\n\";\n          if (ngIfLevelMap[ngIfLevel] >= 0) {\n            ngIfLevelMap[ngIfLevel]++;\n            // console.log('isPath ngIfCounter', [tagName, ngIfCounter]);\n          }\n        }\n\n        //expand doTA templates with expand=1 option\n        if (attr['dota-render'] && attr.expand) {\n          var attrArray = [];\n          //attach data-X attr, and scope-X attr\n          for(x in attr) {\n            if (!x.indexOf('data-')) {\n              attrArray.push('\"' + x.slice(5) + '\":\"' + attr[x] + '\"');\n            } else if (!x.indexOf('scope-')) {\n              attrArray.push('\"' + x.slice(6) + '\":S[\"' + attr[x] + '\"]');\n            }\n          }\n          FnText += indent(level) + 'var P={' + attrArray.join(',') + '},U=\"' + attr['dota-render'] + '\";\\n';\n          //only expand if renderFn is ready in cache, but not in cache-dom (which unneeded)\n          FnText += indent(level) + 'if(typeof doTA.C[U]!==\"undefined\"&&typeof doTA.D[U]===\"undefined\"){' +\n            'R+=doTA.C[U](S,F,P)}; \\n';\n        }\n\n        level++;\n      },\n\n      //void tag no need to write closing tag\n      voidTag: function() {\n        level--;\n\n        if (diffLevel === 2 && level === ngIfLevel && ngIfLevelMap[ngIfLevel] >= 0) {\n          // console.log('ngIfLevelMap1', ngIfLevel, ngIfLevels, ngIfLevelMap);\n          if (ngIfLevelMap[ngIfLevel]) {\n            FnText += indent(level, 1) + \"}else{\" +\n              \"R+='<span id=\\\"'+N+'.\" + uniqueId + '\" hidden=\"\"></span>\\';' +\n              \"N+=\" + ngIfLevelMap[ngIfLevel] + \";}; \\n\";\n          }\n          //save counter\n          ngIfCounterTmp = ngIfLevelMap[ngIfLevel];\n          //clear counter\n          ngIfLevelMap[ngIfLevel] = void 0;\n          //remove last level\n          ngIfLevel = ngIfLevels[--ngIfLevels.length - 1];\n          //add up to previous level\n          if (ngIfLevel) {\n            ngIfLevelMap[ngIfLevel] += ngIfCounterTmp;\n          }\n          // console.log('ngIfLevelMap2', ngIfLevel, ngIfLevels, ngIfLevelMap);\n          if (LevelMap[level] > 0) {\n            LevelMap[level]--;\n          }\n        }\n\n        //close \"if\", \"for\", \"while\" blocks\n        //while is needed because loop and if can be in same tag\n        while (LevelMap[level] > 0) {\n          FnText += indent(level, 1) + '}\\n';\n          LevelMap[level]--;\n        }\n\n        //clear ng-repeat $index\n        if (ngRepeatLevel === level) {\n          LevelVarMap[level] = 0;\n          while (ngRepeatLevel >=0 && typeof LevelVarMap[--ngRepeatLevel] === 'undefined') {}\n        }\n\n        //reset dota-pass when out of scope\n        if (doTAPass >= level) {\n          doTAPass = void 0;\n        }\n      },\n\n      //close tag\n      closeTag: function(tagName) {\n        level--;\n\n        //just write closing tag back\n        FnText += indent(level) + \"R+='</\" + tagName + \">';\\n\";\n\n        //ngIfCounter for most possible uniqueId generation; don't work with loop inside!\n        if (diffLevel === 2 && level === ngIfLevel && ngIfLevelMap[ngIfLevel] >= 0) {\n          // console.log('ngIfLevelMap1', ngIfLevel, ngIfLevels, ngIfLevelMap);\n          if (ngIfLevelMap[ngIfLevel]) {\n            FnText += indent(level, 1) + \"}else{\" +\n              \"R+='<\" + tagName + \" id=\\\"'+N+'.\" + uniqueId + '\" hidden=\"\" ' +\n              (tagName === 'img' || tagName === 'input' || tagName === 'br' || tagName === 'hr' ?\n                '/>' : '></' + tagName + '>')\n              + '\\';' +\n              \"N+=\" + ngIfLevelMap[ngIfLevel] + \"} \\n\";\n          }\n          //save counter\n          ngIfCounterTmp = ngIfLevelMap[ngIfLevel];\n          //clear counter\n          ngIfLevelMap[ngIfLevel] = void 0;\n          //remove last level\n          ngIfLevel = ngIfLevels[--ngIfLevels.length - 1];\n          //add up to previous level\n          if (ngIfLevel) {\n            ngIfLevelMap[ngIfLevel] += ngIfCounterTmp;\n          }\n          // console.log('ngIfLevelMap2', ngIfLevel, ngIfLevels, ngIfLevelMap);\n          if (LevelMap[level] > 0) {\n            LevelMap[level]--;\n          }\n        }\n\n        // console.log('LevelMap1', LevelMap);\n        //close \"if\", \"for\", \"while\" blocks\n        while (LevelMap[level] > 0) {\n          FnText += indent(level, 1) + '}\\n';\n          LevelMap[level]--;\n        }\n        // console.log('LevelMap2', LevelMap);\n\n        if (diffLevel === 2) {\n          if (level === skipLevel) {\n            // console.log('ngIfLevel', [level, skipLevel, ngRepeatLevel])\n            FnText += indent(level, 1) + 'N=O' + level + '; \\n';\n          }\n          if (level === skipLevel) {\n            skipLevel = void 0;\n          }\n        }\n\n        //clear ng-repeat $index\n        if (ngRepeatLevel === level) {\n          LevelVarMap[level] = 0;\n          while (ngRepeatLevel >=0 && typeof LevelVarMap[--ngRepeatLevel] === 'undefined') {}\n        }\n\n        //add blank node if $watch block return nothing, mostly occur with ng-if\n        if (WatchMap[level]) {\n          FnText += indent(level, 1) +\n            \"R=R||('<\" + tagName + ' id=\"' + idHash[uniqueId + '.' + level] +\n            '\" style=\"display:none\"></' + tagName + '>\\');\\n';\n          WatchMap[level] = 0;\n          FnText += indent(level, 2) + 'return R;}; \\n';\n          FnText += indent(level, 2) + 'R+=W.F(S,F,' + (options.params ? '$attr': '0') + ',0,N); \\n';\n        }\n\n        //reset dota-pass when out of scope\n        if (doTAPass >= level) {\n          doTAPass = void 0;\n        }\n      },\n\n      //text node\n      text: function(text) {\n        //console.log([text]);\n        FnText += indent(level) + ('R+=\\'' + interpolate(text) + '\\';\\n')\n          .replace(/\\+''|''\\+/g,'');\n      },\n\n      //comment node\n      comment: function(data) {\n        if (options.comment !== 0) {\n          //console.log(111,[data]);\n          FnText += indent(level) + \"R+='<\" + escapeSingleQuote(data) + \">';\\n\";\n        }\n      }\n    });\n\n    if (watchDiff && diffLevel !== 0) {\n      //http://jsperf.com/hasownproperty-vs-in-vs-undefined/87\n      FnText += indent(0) + 'if(X&&typeof doTA.H[' + uniqueId + ']!==\"undefined\"){doTA.diff' + (diffLevel || '') +\n        '(' + uniqueId + ',R)}' +\n        'doTA.H[' + uniqueId + ']=R;\\n';\n    }\n\n    FnText += indent(0) +'return R;\\n';\n\n    //Default Optimization\n    // - concat possible lines for performance\n    FnText = FnText.replace(/;R\\+=/g,'+').replace(/'\\+'/g,'');\n\n    //extra optimization, which might take some more CPU\n    if (options.optimize && !watchDiff) {\n      FnText = FnText.replace(removeUnneededQuotesRegex,'$1$2');\n    }\n\n    //print the whole function if debug\n    if (options.debug) {\n      /**/console.log(FnText);\n    }\n    // console.log(FnText);\n\n    try {\n      //$scope, $filter\n      if (watchDiff || diffLevel) {\n        compiledFn = new Function('S', 'F', '$attr', 'X', 'N', 'K', 'M', FnText);\n      } else if (options.params) {\n        compiledFn = new Function('S', 'F', '$attr', FnText);\n      } else {\n        compiledFn = new Function('S', 'F', FnText);\n      }\n      if (Watched) {\n        compiledFn = {W:[], F: compiledFn};\n      }\n    } catch (err) {\n      if (typeof console !== \"undefined\") {\n        /**/console.log(\"doTA compile error:\\n\" + FnText);\n      }\n      throw err;\n    }\n\n    // just for less array usage on heap profiling\n    // but this may trigger GC more\n    FnText = LevelMap = LevelVarMap = VarMap = ngIfLevels = ngIfLevelMap = WatchMap = idHash = void 0;\n    return compiledFn;\n  }\n\n  var compiledHash = {};\n  var lastId = 0;\n\n  function initCompileHash(obj) {\n    for (var x in obj) {\n      compiledHash[x] = obj[x];\n      if (obj[x] > lastId) {\n        lastId = obj[x];\n      }\n    }\n  }\n\n  function getUniqueId(key) {\n    if (key) {\n      if (compiledHash[key]) {\n        return compiledHash[key];\n      } else {\n        compiledHash[key] = lastId;\n        return lastId++;\n      }\n    } else {\n      return lastId++;\n    }\n  }\n\n  var doTAObj = {\n    diff: diffPatchExact,\n    diff2: diff2,\n    diff3: diff3,\n    getId: getUniqueId,\n    initCH: initCompileHash,\n    compile: compileHTML,\n    PS: parseStyle,\n    C: {}, //Cached compiled functions\n    D: {}, //Cached DOM to be used by ngDoTA, needed here to prevent unneccessary rendering\n    H: {} //HashMap for TextDiff\n  };\n\n  //warm-up most used functions\n  doTAObj.compile('<div class=\"x {{x}}\" ng-class=\"{x:1}\" ng-repeat=\"x in y\" ng-if=\"x\">x{{x}}</div><!--x-->', {\n    watchDiff: 1, diffLevel: 2});\n\n  return doTAObj;\n})();\n\nif (typeof module !== \"undefined\" && module.exports) {\n  module.exports = doTA;\n//IE8\n} else if (typeof console === \"undefined\") {\n  var noop = function() {};\n  console = {log: noop, time: noop, timeEnd: noop};\n}\n"],"sourceRoot":"/source/"}