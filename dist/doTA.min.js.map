{"version":3,"sources":["doTA.js"],"names":["doTA","N","g","k","e","d","indexOf","charAt","closeTag","substring","comment","c","b","l","r","n","q","a","p","slice","length","replace","toLowerCase","openTag","voidTag","text","L","setAttribute","document","getElementById","console","log","String","prototype","trim","this","Object","watch","unwatch","R","S","T","U","V","W","X","O","C","D","I","diff","H","firstChild","nodeType","nodeValue","diff2","A","E","u","B","createElement","z","m","lastIndexOf","innerHTML","insertBefore","appendChild","parentNode","removeChild","nextSibling","replaceChild","getId","initCH","compile","h","match","J","substr","push","f","F","P","G","loose","watchDiff","diffLevel","$index","undefined","$attr","Math","Date","Array","Infinity","NaN","true","false","null","M","dotaRender","strip","encode",">","<","t","x","w","K","y","v","skip","refresh","elif","exec","test","event","value","id","Q","expand","join","optimize","debug","Function","module","exports","noop","time","timeEnd"],"mappings":"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","file":"doTA.min.js","sourcesContent":["var doTA = (function() {'use strict';\n  /* for ie8 */\n  if (!String.prototype.trim) {\n    String.prototype.trim = function() {\n      return this.replace(/^\\s+|\\s+$/g,'');\n    };\n  }\n\n  /* no, thanks! firefox */\n  if (Object.prototype.watch) {\n    delete Object.prototype.watch;\n    delete Object.prototype.unwatch;\n  }\n\n  // pretty indent for debugging\n  function indent(n, x) {\n    var ret = new Array(n + 2).join('    ');\n    return x ? ret.slice(0, -2 * x) : ret;\n  }\n\n  // decode html entities\n  function decodeEntities(text) {\n    return text.indexOf('&') < 0 ? text : text\n      .replace(/&gt;/g, '>').replace(/&lt;/g, '<')\n      .replace(/&amp;/g, '&').replace(/&quot;/g, '\"');\n  }\n\n  // parse attributes from html open tag and make dict object\n  function parseAttr(chunk, func) {\n    var attr = {}, tagName;\n    var pos = chunk.indexOf(' ');\n    var len, attrName, attrVal;\n    var valStart, valEndPos;\n\n    if (pos !== -1) {\n      tagName = chunk.slice(0, pos);\n      len = chunk.length;\n\n      //console.log(222, [pos, chunk]);\n      while (++pos < len) {\n        var eqPos = chunk.indexOf('=', pos);\n\n        // ** attribute without value (last attribute) **\n        if (eqPos === -1) {\n          attrName = chunk.slice(pos);\n          // console.log('eqPos === -1', [attrName, pos, chunk])\n          if (attrName !== '/') {\n            attr[attrName] = '';\n          }\n          //attr required will be required=\"\", while is valid syntax\n          //http://www.w3.org/TR/html-markup/syntax.html#syntax-attr-empty\n          break;\n        }\n\n        // uncomment this if you need no value attribute in the middle\n        // ** attribute without value (middle attribute) **\n        // var sp_pos = chunk.indexOf(' ', pos);\n        // if (sp_pos > 0 && sp_pos < eqPos) {\n        //   attr[chunk.slice(pos, sp_pos)] = \"\";\n        //   pos = sp_pos;\n        //   continue;\n        // }\n\n        //console.log(33, [eqPos]);\n        attrName = chunk.slice(pos, eqPos);\n        //console.log(331, [attrName]);\n\n        valStart = chunk[eqPos + 1];\n        //console.log(332, [valStart]);\n\n        //if attribute value is start with quote\n        if (valStart === '\"' || valStart === \"'\") {\n          valEndPos = chunk.indexOf(valStart, eqPos + 2);\n          if (valEndPos < 0) { throw 'ERR:Invalid HTML: [' + chunk + ']'; }\n\n          attrVal =  chunk.slice(eqPos + 2, valEndPos);\n          attr[attrName] =0>attrVal.indexOf(\"&\")?attrVal:attrVal.replace(/&gt;/g,\">\").replace(/&lt;/g,\"<\").replace(/&amp;/g,\"&\").replace(/&quot;/g,'\"'); //INLINE;\n          pos = valEndPos + 1;\n          //console.log(311, [valEndPos, attrName, attrVal]);\n        } else {\n\n          valEndPos = chunk.indexOf(' ', eqPos + 2);\n\n          //when no more attributes\n          if (valEndPos < 0) {\n            attrVal =  chunk.slice(eqPos + 1);\n            attr[attrName] =0>attrVal.indexOf(\"&\")?attrVal:attrVal.replace(/&gt;/g,\">\").replace(/&lt;/g,\"<\").replace(/&amp;/g,\"&\").replace(/&quot;/g,'\"'); //INLINE;\n            //console.log(442, [attrVal]);\n            break;\n\n          } else {\n            attrVal =  chunk.slice(eqPos + 1, valEndPos);\n            attr[attrName] =0>attrVal.indexOf(\"&\")?attrVal:attrVal.replace(/&gt;/g,\">\").replace(/&lt;/g,\"<\").replace(/&amp;/g,\"&\").replace(/&quot;/g,'\"'); //INLINE;\n            //console.log(313, [eqPos, valEndPos, attrVal]);\n            pos = valEndPos;\n          }\n        }\n      }\n\n      tagName = tagName.toLowerCase();\n      if (tagName === 'input' || tagName === 'img') {\n        //http://www.w3.org/TR/html-markup/syntax.html\n        //area, base, br, col, command, embed, hr, img, input, keygen, link, meta, param, source, track, wbr\n        func.openTag(tagName, attr, 1);\n        func.voidTag();\n      } else if (attrName === '/') {\n        func.openTag(tagName, attr);\n        func.closeTag(tagName);\n      } else {\n        func.openTag(tagName, attr);\n      }\n\n    // no attributes\n    } else {\n\n      // self closing, explicit\n      if (chunk.charAt(chunk.length - 1) === '/') {\n        tagName = chunk.slice(0, -1).toLowerCase();\n\n        if (tagName === 'br' || tagName === 'hr') {\n          func.openTag(tagName, attr, 1);\n          func.voidTag();\n        } else {\n          func.openTag(tagName, attr);\n          func.closeTag(tagName);\n        }\n      } else {\n        tagName = chunk.toLowerCase();\n\n        // self closing, implicit\n        if (tagName === 'br' || tagName === 'hr') {\n          func.openTag(tagName, attr, 1);\n          func.voidTag();\n        } else {\n          func.openTag(tagName, attr);\n        }\n      }\n    }\n\n  }\n\n  var events = ' change click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste ';\n  var valid_chr = '_$abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n\n  // minimal stripped down html parser\n  function parseHTML(html, func) {\n    if (!html) { return; }\n    var prevPos = 0, pos = html.indexOf('<');\n    do {\n      if (html.charAt(pos) === '<') {\n        pos++;\n        if (html.charAt(pos) === '/') {\n          prevPos = ++pos;\n          pos = html.indexOf('>', prevPos);\n          //close tag must be like </div>, but not <div />\n          // console.log(['closetag', prevPos, pos, html.substring(prevPos, pos)])\n          func.closeTag(html.substring(prevPos, pos));\n        } else if (html.charAt(pos) === '!') {\n          prevPos = pos;\n          pos = html.indexOf('>', prevPos);\n          // console.log(['comment', prevPos, pos, html.substring(prevPos, pos)])\n          func.comment(html.substring(prevPos, pos));\n        } else {\n          prevPos = pos;\n          pos = html.indexOf('>', prevPos);\n          // console.log(['opentag', prevPos, pos, html.substring(prevPos, pos), parseAttr(html.substring(prevPos, pos))])\n          // func.openTag.apply(this, parseAttr(html.substring(prevPos, pos)));\n          parseAttr(html.substring(prevPos, pos), func);\n        }\n      } else if (html.charAt(pos) === '>') { //&& html.charAt(pos + 1) !== '<'\n        prevPos = ++pos;\n        pos = html.indexOf('<', prevPos);\n        if (pos > prevPos) {\n          // console.log(['text', prevPos, pos, html.substring(prevPos, pos)])\n          func.text(html.substring(prevPos, pos));\n        }\n      } else {\n        console.error('Parse ERR?', [prevPos, pos, html.substring(prevPos, pos), html.slice(pos)]);\n        break;\n      }\n\n    } while (pos > 0);\n  }\n\n  //diff and patch dom with exact same structure\n  function diffPatchExact(prevKey, html2) {\n    var html1 = doTA.H[prevKey];\n    var prevPos1 = 0, pos1 = html1.indexOf('<');\n    var prevPos2 = 0, pos2 = html2.indexOf('<');\n    var tagId = '', elem, part1, part2;\n    var posx, endPosx;\n\n    do {\n      if (html1.charAt(pos1) === \"<\") {\n        pos1++;\n        pos2++;\n        if (html1.charAt(pos1) === \"/\" || html1.charAt(pos1) === \"!\") {\n          //don't patch comment node and close tag.\n          pos1 = html1.indexOf('>', pos1);\n          pos2 = html2.indexOf('>', pos2);\n        } else {\n          prevPos1 = pos1;\n          prevPos2 = pos2;\n          pos1 = html1.indexOf('>', prevPos1);\n          pos2 = html2.indexOf('>', prevPos2);\n          part1 = html1.substring(prevPos1, pos1);\n          part2 = html2.substring(prevPos2, pos2);\n          //attributes\n          if (part1 !== part2) {\n            // console.log('openTag', [part1, part2])\n            tagId = parsePatchAttr(part1, part2);\n          } else {\n            //record id\n            //tagId = getTagId(part1);\n            posx = part1.indexOf(' id=\"');\n            0 <= posx && (posx += 5, endPosx = part1.indexOf('\"', posx), tagId = part1.substring(posx, endPosx));\n          }\n        }\n\n      //text node\n      } else if (html1.charAt(pos1) === '>') {\n        prevPos1 = ++pos1;\n        prevPos2 = ++pos2;\n\n        pos1 = html1.indexOf('<', prevPos1);\n        pos2 = html2.indexOf('<', prevPos2);\n        //textNode, only support firstChild here\n        if (pos2 > prevPos2) {\n          var text1 = html1.substring(prevPos1, pos1);\n          var text2 = html2.substring(prevPos2, pos2);\n          if (text1 !== text2) {\n            elem = document.getElementById(tagId);\n            if (elem) {\n              if (elem.firstChild && elem.firstChild.nodeType === 3) {\n                // console.log('textApplied', [text1, text2]);\n                elem.firstChild.nodeValue = text2;\n              } //else to log something?\n            } else {\n              console.log('tag not found', [tagId]);\n            }\n          }\n        }\n\n      }\n\n    } while(pos1 > 0);\n  }\n\n  // find position of outerHTML end\n  // this function will be inline during building\n  function getOuterHTMLEnd(HTML, START_POS) {\n    var LVL = 1, POS = START_POS;\n    do {\n      POS = HTML.indexOf('<', POS + 1);\n      if (HTML.charAt(POS + 1) === '/') {\n        LVL--;\n      } else {\n        LVL++;\n      }\n      POS = HTML.indexOf('>', POS);\n      if (HTML.charAt(POS - 1) === '/') { //self closing\n        LVL--;\n      }\n    } while (LVL > 0);\n\n    // console.log('getOutHTML', tagName, [tagName, pos2, pos2, ])\n    return ++POS;\n  }\n\n  // FlatDOM: diff html as text and patch dom nodes\n  function diffPatchChildren(prevKey, html2) {\n    var html1 = doTA.H[prevKey];\n    var prevPos1 = 0, pos1 = html1.indexOf('<');\n    var prevPos2 = 0, pos2 = html2.indexOf('<');\n    var tagId1, tagId2, elem1, elem2, part1, part2;\n    var tagNo1 = 0, tagNo2 = 0;\n    var newNode = document.createElement('div');\n    var parentNode, nextSibling;\n    var tagStartPos1, tagStartPos2;\n    var dirty1 = 0, dirty2 = 0;\n    var prevTagId2;\n    var LVL; //this is needed for fnInline\n    // console.log(html1);\n    // console.log(html2);\n\n    for(;;) {\n      // console.log('before', [dirty1, dirty2], [tagId1, tagId2], [html1.substr(pos1, 20), html2.substr(pos2, 20)]);\n\n      if (pos1 >= 0 && dirty2 < 2) {\n        prevPos1 = pos1;\n        pos1 = html1.indexOf(' id=\"', prevPos1);\n        if (pos1 > 0) {\n          prevPos1 = pos1 + 5;\n          pos1 = html1.indexOf('\"', prevPos1);\n          tagId1 = html1.substring(prevPos1, pos1);\n          tagNo1 = tagId1^0;\n        }\n        if (dirty2 && tagNo1 > tagNo2) {\n          dirty2 = 2;\n        }\n      }\n\n      // console.log('middle', [tagId1, tagId2], [html1.substr(pos1, 20), html2.substr(pos2, 20)]);\n\n      if (pos2 >= 0 && dirty1 < 2) {\n        prevTagId2 = tagId2;\n        prevPos2 = pos2;\n        pos2 = html2.indexOf(' id=\"', prevPos2);\n        if (pos2 > 0) {\n          prevPos2 = pos2 + 5;\n          pos2 = html2.indexOf('\"', prevPos2);\n          tagId2 = html2.substring(prevPos2, pos2);\n          tagNo2 = tagId2^0;\n        }\n        if (dirty1 && tagNo2 > tagNo1) {\n          dirty1 = 2;\n        }\n      }\n\n      // console.log('after', [dirty1, dirty2], [tagId1, tagId2],\n      //   [pos1, pos2], [html1.substr(pos1, 20), html2.substr(pos2, 20)]);\n\n      //exist inifite loop\n      if (pos1 < 0 && pos2 < 0) break;\n\n      //only if there is remaining tags\n      if (pos1 > 0 && pos2 > 0) {\n\n        //same node\n        if (tagNo1 === tagNo2) {\n          tagStartPos1 = ++pos1;\n          pos1 = html1.indexOf('>', pos1);\n          part1 = html1.substring(tagStartPos1, pos1);\n\n          tagStartPos2 = ++pos2;\n          pos2 = html2.indexOf('>', pos2);\n          part2 = html2.substring(tagStartPos2, pos2);\n\n          //attr really different\n          if (part1 !== part2) {\n            elem1 = document.getElementById(tagId1);\n            parsePatchAttr(part1, part2, elem1);\n            // console.warn('patch node', [tagId1, tagId2], [pos1, pos2], [tagStartPos1, tagStartPos2], [part1, part2])\n          } else {\n            //?\n            elem1 = 0;\n          }\n\n          //for text diff\n          prevPos1 = ++pos1;\n          pos1 = html1.indexOf('<', prevPos1);\n          part1 = html1.substring(prevPos1, pos1);\n          prevPos2 = ++pos2;\n          pos2 = html2.indexOf('<', prevPos2);\n          part2 = html2.substring(prevPos2, pos2);\n\n          //for text node really diff\n          if (part1 !== part2) {\n            if (!elem1) {\n              elem1 = document.getElementById(tagId1);\n            }\n            if (elem1.firstChild && elem1.firstChild.nodeType === 3) {\n              elem1.firstChild.nodeValue = part2;\n            }\n            // console.warn('patch text node', [tagId1, tagId2], [part1, part2])\n          }\n          dirty1 = dirty2 = 0;\n          continue;\n        }\n      }\n\n      if (dirty1 && ((tagNo1 > tagNo2 && pos2 > 0) || pos1 < 0)) {\n        // console.warn('dirty1**', [dirty1, dirty2], [tagNo1, tagNo2]);\n        dirty2 = 2;\n        dirty1 = 0;\n      }\n      if (dirty2 && ((tagNo2 > tagNo1 && pos1 > 0) || pos2 < 0)) {\n        // console.warn('dirty2**', [dirty1, dirty2], [tagNo1, tagNo2]);\n        dirty1 = 2;\n        dirty2 = 0;\n      }\n\n      if (dirty2 && (tagNo1 > tagNo2 || (pos1 < 0 && pos2 > 0))) {\n        // console.log('dirty2', [tagNo1, tagNo2]);\n        tagStartPos2 = html2.lastIndexOf('<', pos2 - 6);\n        LVL=1,pos2=tagStartPos2;do pos2=html2.indexOf(\"<\",pos2+1),\"/\"===html2.charAt(pos2+1)?LVL--:LVL++,pos2=html2.indexOf(\">\",pos2),\"/\"===html2.charAt(pos2-1)&&LVL--;while(0<LVL);++pos2; //INLINE\n\n        newNode.innerHTML = html2.slice(tagStartPos2, pos2);\n        // console.log('newNode', [tagId1, tagId2, prevTagId2], newNode.innerHTML, nextSibling, parentNode);\n        if (parentNode) {\n          if (nextSibling) {\n            if (newNode.firstChild) {\n              elem2 = parentNode.insertBefore(newNode.firstChild, nextSibling);\n            } else {\n              console.error('newNode is broken', [newNode], [html2.slice(tagStartPos2, pos2)])\n            }\n          } else {\n            parentNode.appendChild(newNode.firstChild);\n          }\n        } else {\n          parentNode = document.getElementById(prevTagId2);\n          parentNode.appendChild(newNode.firstChild);\n        }\n        // console.warn('add node', [tagNo1, tagNo2], elem2);\n        continue;\n      }\n\n      //node is gone\n      if (dirty1 && (tagNo2 > tagNo1 || (pos2 < 0 && pos1 > 0))) {\n        // console.log('dirty1', [tagId1, tagId2]);\n        elem1 = document.getElementById(tagId1);\n        if (elem1) {\n          elem1.parentNode.removeChild(elem1);\n          //skip\n          LVL=1,pos1=pos1;do pos1=html1.indexOf(\"<\",pos1+1),\"/\"===html1.charAt(pos1+1)?LVL--:LVL++,pos1=html1.indexOf(\">\",pos1),\"/\"===html1.charAt(pos1-1)&&LVL--;while(0<LVL);++pos1; //INLINE\n          // console.warn('removeChild', [tagNo1, tagNo2], elem1, [html1.substr(pos1, 15)]);\n        } else {\n          console.error('tag not found: elem1', [tagId1]);\n        }\n        continue;\n      }\n\n      if (pos1 > 0 && pos2 > 0) {\n        if (tagNo1 !== tagNo2 && !dirty2 && !dirty1) {\n          // console.log('before delete', [tagId1, tagId2]);\n          elem1 = document.getElementById(tagId1);\n          if (elem1) {\n            nextSibling = elem1.nextSibling;\n            parentNode = elem1.parentNode;\n\n            tagStartPos2 = html2.lastIndexOf('<', pos2 - 6);\n            LVL=1,pos2=tagStartPos2;do pos2=html2.indexOf(\"<\",pos2+1),\"/\"===html2.charAt(pos2+1)?LVL--:LVL++,pos2=html2.indexOf(\">\",pos2),\"/\"===html2.charAt(pos2-1)&&LVL--;while(0<LVL);++pos2; //INLINE\n            newNode.innerHTML = html2.substring(tagStartPos2, pos2);\n            parentNode.replaceChild(newNode.firstChild, elem1);\n\n            LVL=1,pos1=pos1;do pos1=html1.indexOf(\"<\",pos1+1),\"/\"===html1.charAt(pos1+1)?LVL--:LVL++,pos1=html1.indexOf(\">\",pos1),\"/\"===html1.charAt(pos1-1)&&LVL--;while(0<LVL);++pos1; //INLINE\n            // console.log( [pos1, newPos],[html1.substring(pos1, newPos)]);\n            // console.warn('replaced node', [tagId1, tagId2], [tagNo1, tagNo2], elem1);\n            if (tagNo1 < tagNo2) dirty2 = 1;\n            if (tagNo1 > tagNo2) dirty1 = 1;\n          } else {\n            console.error('tag not found: elem1', [tagId1]);\n          }\n        }\n      }\n\n    } //infinite loop\n\n  }\n\n  // parse attributes from html open tag and patch DOM when different\n  function parsePatchAttr(chunk1, chunk2, elem) {\n    var tagId;\n    var pos1 = chunk1.indexOf(' ');\n    var eqPos1, eqPos2;\n    var valEndPos1, valEndPos2, posDiff = 0;\n    var attrName, attrVal1, attrVal2;\n    var len1 = chunk1.length;\n    // console.log('chunks', [chunk1, chunk2]);\n    if (pos1 !== -1) {\n      while (++pos1 < len1) {\n        eqPos1 = chunk1.indexOf('=\"', pos1);\n        if (eqPos1 < 0) break;\n        attrName = chunk1.slice(pos1, eqPos1);\n\n        valEndPos1 = chunk1.indexOf('\"', eqPos1 + 2);\n        attrVal1 =  chunk1.slice(eqPos1 + 2, valEndPos1);\n        if (!elem && attrName === 'id') {\n          tagId = attrVal1;\n          elem = document.getElementById(tagId);\n          if (!elem) {\n            return console.log('tag not found', [tagId]);\n          }\n        } else {\n          eqPos2 = eqPos1 + posDiff;\n          valEndPos2 = chunk2.indexOf('\"', eqPos2 + 2);\n          attrVal2 =  chunk2.slice(eqPos2 + 2, valEndPos2);\n          posDiff = valEndPos2 - valEndPos1;\n          if (attrVal1 !== attrVal2) {\n            // console.log('setAttribute', [attrName, attrVal1, attrVal2], [chunk1, chunk2])\n            elem.setAttribute(attrName, attrVal2);\n          }\n        }\n        pos1 = valEndPos1 + 1;\n\n      } //while\n    }\n    return tagId;\n  }\n\n  // extract value of id from part of html open tag\n  // only id=\"xxx\" supported, this is internal use, so it's always double-quotes\n  // this function is inlined during building\n  function getTagId(partial, start) {\n    var pos = partial.indexOf(' id=\"', start), endPos;\n    if (pos >= 0) {\n      pos += 5;\n      endPos = partial.indexOf('\"', pos);\n      return partial.substring(pos, endPos);\n    }\n  }\n\n  // split filters into array, take care of | and || as different\n  function splitFilters(input) {\n    var pos = input.indexOf('|');\n    if (pos === -1) {\n      return [input];\n    }\n    var prevPos = 0;\n    var ret = [];\n    while (pos !== -1) {\n      if (input.charAt(pos + 1) === '|') {\n        pos += 2;\n      } else {\n        ret.push(input.substring(prevPos, pos));\n        prevPos = ++pos;\n      }\n      pos = input.indexOf('|', pos);\n    }\n    if (prevPos < input.length) {\n      ret.push(input.substr(prevPos));\n    }\n    return ret;\n  }\n\n  // ToDo: check compile performance with regex\n  var ngClassRegex = /('[^']+'|\"[^\"]+\"|[\\w$]+)\\s*:\\s*((?:[$.\\w]+|\\([^)]+\\)|[^},])+)/g;\n  var varOrStringRegex = /'[^']*'|\"[^\"]*\"|[\\w$]+|[^\\w$'\"]+/g;\n  var quotedStringRegex = /\"[^\"]*\"|'[^']*'/g;\n  var whiteSpaceRegex = /\\s{2,}|\\n/g;\n  var removeUnneededQuotesRegex = /\\b([\\w_-]+=)\"([^\"'\\s]+)\"(?=[\\s>])/g;\n  var lazyNgAttrRegex = /^(?:src|alt|title|href)/;\n  // https://github.com/kangax/html-minifier/issues/63\n  var noValAttrRegex = /^(?:checked|selected|disabled|readonly|multiple|required|hidden|nowrap)/;\n  var $indexRegex = /\\$index/g;\n\n  // exported as doTA.compile\n  function compileHTML(template, options) {\n    options = options || {};\n    var val_mod = options.loose ? \"||''\" : '';\n    var watchDiff = options.watchDiff;\n    var diffLevel = +options.diffLevel;\n    var VarMap = {$index: 1, undefined: 1, $attr: 1,\n      Math: 1, Date: 1, String: 1, Object: 1, Array: 1, Infinity: 1, NaN: 1,\n      true: 1, false: 1, null: 1};\n    var level = 0, ngRepeatLevel;\n    var ngIfLevel, ngIfSkipLevel, ngIfCounterTmp, ngIfLevels = [], ngIfLevelMap = {};\n    var LevelMap = {}, LevelVarMap = {};\n    var WatchMap = {}, Watched;\n    var doTAPass, doTAContinue;\n    var compiledFn;\n    var uniqueId = this.getId(options.dotaRender);\n    var idHash = {};\n\n    var FnText = indent(level) + \"'use strict';var \" +\n      (watchDiff ? 'N=1,J=' + uniqueId + ',' : '') +\n      \"R='';\\n\"; //ToDO: check performance on var declaration\n\n    //clean up extra white spaces and line break\n    template = template.replace(whiteSpaceRegex, ' ');\n\n    if (options.strip) {\n      template = template.replace(/>\\s+/g, '>').replace(/\\s+</g, '<');\n    }\n\n    // when encode is set, find strings and encode < and >, or parser will throw error.\n    if (options.encode) {\n      template = template.replace(quotedStringRegex, function($0) {\n        return $0.replace(/[<>]/g, function($00) {\n          return {'>': '&gt;', '<': '&lt;'}[$00];\n        });\n      });\n    }\n\n    // attach plain variables to scope variables\n    function attachScope(v) {\n      //console.log(VarMap, [v]);\n      if (v) {\n        //var DEBUG = /error/.test(v);\n        //DEBUG && console.log(11, [v]);\n\n        //ToDo: still buggy, this need to improve\n        var vv = '';\n        var matches = v.match(varOrStringRegex);\n        //DEBUG && console.log(12, matches);\n        for(var i = 0; i < matches.length; i++) {\n\n          if (valid_chr.indexOf(matches[i].charAt(0)) >= 0 && !VarMap[matches[i]] &&\n            (!i || matches[i-1][matches[i-1].length-1] !== '.')) {\n            vv += 'S.' + matches[i];\n          } else {\n            if (matches[i].indexOf('$index') >= 0) {\n              //console.log([val], LevelMap[level]);\n              //for(var j = level; j >= 0; j--) {\n              //  if (LevelVarMap[j]) {\n                  vv += matches[i].replace($indexRegex, LevelVarMap[ngRepeatLevel]);\n                  //break;\n                //}\n              //}\n            } else {\n              vv += matches[i];\n            }\n          }\n        }\n        //DEBUG && console.log(55, vv);\n        return vv;\n      }\n      return v;\n    }\n\n    // escape single quotes with backslash\n    function escapeSingleQuote(str) {\n      var quotePos = str.indexOf(\"'\");\n      if (quotePos >= 0) {\n        var ret = '';\n        var prevQuotePos = 0;\n        do {\n          ret += str.substring(prevQuotePos, quotePos);\n          //escaped quote\n          if (str.charAt(quotePos - 1) !== '\\\\') {\n            ret += \"\\\\\";\n          }\n          prevQuotePos = quotePos;\n          quotePos = str.indexOf(\"'\", prevQuotePos + 1);\n        } while (quotePos > 0);\n        ret += str.substr(prevQuotePos);\n        return ret;\n      } else {\n        return str;\n      }\n    }\n\n    // interpolation\n    function interpolate(str) {\n      var pos = str.indexOf('{{');\n      if (pos >= 0) {\n        var prevPos = 0;\n        var ret = '';\n        var outsideStr, insideStr;\n        do {\n          outsideStr = str.substring(prevPos, pos);\n          ret += escapeSingleQuote(outsideStr);\n\n          //skip {{\n          prevPos = pos + 2;\n          pos = str.indexOf('}}', prevPos);\n\n          insideStr = str.substring(prevPos, pos);\n          ret += \"'+(\" + attachFilter(insideStr) + val_mod + \")+'\";\n\n          //skip }} for next\n          prevPos = pos + 2;\n          pos = str.indexOf('{{', prevPos);\n        } while (pos > 0);\n\n        //remaining text outside interpolation\n        ret += escapeSingleQuote(str.substr(prevPos));\n        return ret;\n      } else {\n        return escapeSingleQuote(str);\n      }\n    }\n\n    // attach $filters\n    function attachFilter($1) {\n      //console.log(333,$1);\n      var pos = $1.indexOf('|');\n      if (pos === -1) {\n        return attachScope($1);\n      } else {\n        //ToDo: check this line later\n        var v = splitFilters($1);\n        var val = attachScope(v[0]);\n        var prevColonPos = 0, colonPos;\n        var filter;\n\n        //parse each filters\n        for(var i = 1; i < v.length; i++) {\n          filter = v[i];\n\n          colonPos = filter.indexOf(':');\n          //filter with params\n          if (colonPos > 0) {\n            val = \"F('\" + filter.slice(prevColonPos, colonPos).trim() + \"')(\" + val;\n            prevColonPos = ++colonPos;\n            colonPos = filter.indexOf(':', prevColonPos);\n            while (colonPos > 0) {\n              val += ',' + attachScope(filter.slice(prevColonPos, colonPos));\n              prevColonPos = ++colonPos;\n              colonPos = filter.indexOf(':', prevColonPos);\n            }\n            val += ',' + attachScope(filter.substr(prevColonPos)) + ')';\n\n          //filter without params\n          } else {\n            val = \"F('\" + filter.trim() + \"')(\" + val + ')';\n          }\n\n        }\n        return val;\n      }\n    }\n\n    //parse the element\n    parseHTML(template, {\n      //open tag with attributes\n      openTag: function(tagName, attr, selfClosing) {\n        // debug && console.log('openTag', [tagName, attr]);\n        var interpolatedAttr = {}, customId, tagId, noValAttr = '', attrName, attrVal, oneTimeBinding;\n\n        //skip parsing ng-if, ng-repeat, ng-class with, dota\n        // but interpolation will still be evaluated (by-design)\n        // to avoid this behavior, use ng-bind instead of {{}}\n        //  and create new scope with scope=1 in dota-render, or $watchers will never destroy.\n        if (attr['dota-pass']) {\n          doTAPass = level; doTAContinue = 0;\n        //re-enable dota parsing\n        } else if (attr['dota-continue']) {\n          doTAContinue = level;\n        }\n\n        //unless dota-pass or with dota-continue\n        if (!doTAPass || doTAContinue) {\n          //ng-repeat to while/for loop\n          if (attr['ng-repeat']) {\n            //console.log(21,[x], [val]);\n            LevelMap[level] = LevelMap[level] ? LevelMap[level] + 1 : 1;\n            var idx = 'i' + level, l = 'l'+ level;\n            var NG_REPEAT = attr['ng-repeat'];\n            var inPos = NG_REPEAT.indexOf(' in ');\n            var repeatVar = NG_REPEAT.substr(0, inPos), repeatSrc = NG_REPEAT.substr(inPos + 4);\n            var commaPos = repeatVar.indexOf(',');\n            var pipePos = repeatSrc.indexOf('|'), repeatSrcNew;\n            var colonPos, x;\n\n            //store variable name to use for $index later\n            //this is ng-repeat specific, LevelMap[level] is same for ng-if too\n            LevelVarMap[level] = idx;\n            ngRepeatLevel = level;\n\n            if (pipePos > 0) {\n              repeatSrcNew = attachFilter(repeatSrc);\n            } else {\n              colonPos = repeatSrc.indexOf(':');\n              if (colonPos < 0) {\n                repeatSrcNew = attachScope(repeatSrc);\n              }\n            }\n\n            // Range: \"i in 1:10\" ==> (for i = 1; i < 10; i++)\n            if (colonPos > 0) {\n              var start = repeatSrc.substr(0, colonPos), end, step;\n              var anotherColon = repeatSrc.indexOf(':', ++colonPos);\n              if (anotherColon > 0) {\n                end = repeatSrc.substring(colonPos, anotherColon);\n                step = repeatSrc.substr(anotherColon + 1);\n              } else {\n                end = repeatSrc.substr(colonPos);\n                step = 1;\n              }\n              // console.log([start, end, step])\n\n              FnText += indent(level, 1) + 'for(var ' +\n                (diffLevel ? 'O' + level + '=N+' + (attr.skip || (end - start) / step + 1) + ',': '') +\n                repeatVar + '=' + start + ';' +\n                repeatVar + (step > 0 ? '<' : '>') + end + ';' + repeatVar + '+=' + step + '){\\n';\n              VarMap[repeatVar] = 1;\n\n            // Object: \"k, v in {}\" ==> (for in {})\n            } else if (commaPos > 0) {\n              var key = repeatVar.substr(0, commaPos);\n              var value = repeatVar.substr(commaPos + 1);\n              FnText += indent(level, 1) + 'var ' +\n                (diffLevel ? 'O' + level + '=N+' + (attr.skip || 100) + ',': '') +\n                value + ',D' + level + '=' + repeatSrcNew + ';\\n';\n              FnText += indent(level, 1) + 'for(var ' + key + ' in D' + level + '){\\n';\n              //                             space is needed for manual uglify  ->  vvv\n              FnText += indent(level) + value + ' = ' + 'D' + level + '[' + key + ']; \\n';\n              VarMap[key] = VarMap[value] = 1;\n\n            // Array: \"k in []\" ==> while loop\n            } else {\n              FnText += indent(level, 1) + 'var ' +\n                repeatVar + ',D' + level + '=' + repeatSrcNew + ','\n                + idx + '=-1,' + l + '=D' + level + '.length' +\n                (diffLevel ? ',O' + level + '=N+' + (attr.skip || l): '') +\n                ';\\n';\n              FnText += indent(level, 1) + 'while(++' + idx + '<' + l + '){\\n';\n              //                        space is needed for manual uglify  ->  vvv\n              FnText += indent(level) + repeatVar + '=D' + level + '[' + idx + ']; \\n';\n              VarMap[repeatVar] = 1;\n            }\n            //remote attribute not to get forwarded to angular\n            attr['ng-repeat'] = void 0;\n          }\n\n          //re-render sub template\n          if (attr.refresh) {\n            customId = 1;\n            oneTimeBinding = attr.refresh.indexOf('::');\n            FnText += indent(level, 2) +\n              (!Watched ? 'var ' + (watchDiff ? '': 'N=1,') + 'T=this;T.W=[];' : '') +\n              'var W={N:N,I:N+\"' + '.' + uniqueId + '\",W:\"' +\n              (oneTimeBinding >=0 ? attr.refresh.substr(oneTimeBinding + 2) + '\",O:1': attr.refresh + '\"') +\n              (attr.compile ? ',C:1' : '') +\n              '};T.W.push(W);\\n';\n            WatchMap[level] = Watched = 1;\n            FnText += indent(level, 2) + 'W.F=function(S,F,$attr,X,N){var R=\"\";\\n';\n            attr.refresh = void 0;\n          }\n\n          //ng-if to javascript if\n          if (attr['ng-if']) {\n            if (diffLevel) {\n              ngIfLevel = level;\n              ngIfLevels.push(level);\n              ngIfLevelMap[level] = 0;\n              if (attr.skip) {\n                ngIfSkipLevel = level;\n                FnText += indent(level, 1) + 'var O' + level + '=N+' + attr.skip + '; \\n';\n              }\n            }\n            LevelMap[level] = LevelMap[level] ? LevelMap[level] + 1 : 1;\n            FnText += indent(level, 1) + 'if('+ attachScope(attr['ng-if']) +'){\\n';\n            // console.log('ng-if starts here', level);\n            attr['ng-if'] = void 0;\n          }\n\n          if (attr['elif'] !== void 0) {\n            FnText += indent(level, 1) + 'else if('+ attachScope(attr['elif']) +'){\\n';\n            LevelMap[level] = LevelMap[level] ? LevelMap[level] + 1 : 1;\n            attr['elif'] = void 0;\n          }\n\n          if (attr['else'] !== void 0 && !watchDiff) {\n            FnText += indent(level, 1) + 'else{\\n';\n            LevelMap[level] = LevelMap[level] ? LevelMap[level] + 1 : 1;\n            attr['else'] = void 0;\n          }\n\n          if (attr['ng-init']) {\n            FnText += indent(level) + attachScope(attr[\"ng-init\"]) + '; \\n';\n            attr['ng-init'] = void 0;\n          }\n\n          if (attr['ng-class']) {\n            var ngScopedClass = attachScope(attr['ng-class']), match;\n            interpolatedAttr.class = (attr.class ? interpolate(attr.class) : '');\n            while((match = ngClassRegex.exec(ngScopedClass)) !== null) {\n              interpolatedAttr.class +=\n                (\"'+(\" + match[2] + '?' +\n                  \"'\" + (interpolatedAttr.class ? ' ' : '') + match[1].replace(/['\"]/g, '') +\n                  \"':'')+'\");\n            }\n            attr['ng-class'] = void 0;\n          }\n\n          if (attr['ng-show']) {\n            interpolatedAttr.class = (interpolatedAttr.class || attr.class || '');\n            interpolatedAttr.class += \"'+(\" + attachScope(attr['ng-show']) +\n              \"?'':'\" + (interpolatedAttr.class ? ' ' : '') + \"ng-hide')+'\";\n            attr['ng-show'] = void 0;\n          }\n\n          if (attr['ng-hide']) {\n            interpolatedAttr.class = (interpolatedAttr.class || attr.class || '');\n            interpolatedAttr.class += \"'+(\" + attachScope(attr['ng-hide']) +\n              \"?'\" + (interpolatedAttr.class ? ' ' : '') + \"ng-hide':'')+'\";\n            attr['ng-hide'] = void 0;\n          }\n\n          //remove +''+ from class, for unnecessary string concat\n          if (interpolatedAttr.class) {\n            interpolatedAttr.class = interpolatedAttr.class.replace(/\\+''\\+/g, '+');\n            attr.class = void 0;\n          } else if (attr.class) {\n            interpolatedAttr.class = interpolate(attr.class);\n            attr.class = void 0;\n          }\n\n          // expand interpolations on attributes, and some more\n          for (x in attr) {\n            attrVal = attr[x];\n            if (attrVal === void 0) { continue; }\n\n            // some ng- attributes\n            if (x.substr(0, 3) === 'ng-') {\n              //some ng-attr are just don't need it here.\n              attrName = x.substr(3);\n              //something like ng-src, ng-href, etc.\n              if (lazyNgAttrRegex.test(attrName)) {\n                x = attrName;\n\n              //convert ng-events to dota-events, to be bind later with native events\n              } else if (options.event && events.indexOf(' ' + attrName + ' ') >= 0) {\n                //adding attr \"de\" for querySelectorAll in ngDoTA\n                interpolatedAttr.class = interpolatedAttr.class ? 'de ' + interpolatedAttr.class : 'de';\n                // interpolatedAttr.de = 1;\n                x = 'de-' + attrName;\n\n              } else if (noValAttrRegex.test(attrName)) {\n                noValAttr += \"'+(\" + attachScope(attrVal) + \"?' \" + attrName + \"=\\\"\\\"':'')+'\";\n                //noValAttr will attach later\n                continue;\n\n              //ng-value\n              } else if (attrName === 'value') {\n                interpolatedAttr.value = \"'+(\" + attachScope(attrVal) + \")+'\";\n                continue;\n              }\n            }\n\n            //ng-repeat loop variables are not available!\n            // only way to acccess is to use $index like \"data[$index]\"\n            // instead of \"item\" as in \"item in data\"\n            if (attrVal.indexOf('$index') >= 0) {\n              //console.log([val], LevelMap[level]);\n              //for(var j = level; j >= 0; j--) {\n              //  if (LevelVarMap[j]) {\n                  interpolatedAttr[x] = interpolate(attrVal).replace($indexRegex, \"'+\" + LevelVarMap[ngRepeatLevel] + \"+'\");\n              //    break;\n              //  }\n              //}\n            } else {\n              interpolatedAttr[x] = interpolate(attrVal);\n            }\n          }\n\n        // pass all attributes to angular, except interpolation and $index\n        } else {\n          for (x in attr) {\n            //or just do use escapeSingleQuote\n\n            if (attr[x].indexOf('$index') >= 0) {\n              //console.log([val], LevelMap[level]);\n              //for(var j = level; j >= 0; j--) {\n              //  if (LevelVarMap[j]) {\n                  interpolatedAttr[x] = interpolate(attr[x]).replace($indexRegex, \"'+\" + LevelVarMap[ngRepeatLevel] + \"+'\");\n              //    break;\n              //  }\n              //}\n            } else {\n              interpolatedAttr[x] = interpolate(attr[x]);\n            }\n          }\n        }\n\n        //write tag back as string\n        FnText += indent(level) + \"R+='<\" + tagName;\n\n        //make id attr come before anything\n        if (customId || watchDiff) {\n          tagId = idHash[uniqueId + '.' + level] = interpolatedAttr.id || (\"'+(N++)+'.\" + uniqueId);\n          FnText += ' id=\"' + tagId + '\"';\n          if (interpolatedAttr.id) {\n            interpolatedAttr.id = void 0;\n          }\n        }\n\n        //write back attributes\n        for(var k in interpolatedAttr) {\n          FnText += \" \" + k + '=\"' + interpolatedAttr[k] + '\"';\n        }\n\n        //attach boolean attributes at last\n        FnText += noValAttr +  (selfClosing ? ' /' : '') + \">';\\n\";\n\n        if (watchDiff) {\n          // FnText += indent(level) + \"N++; \\n\";\n          if (ngIfLevelMap[ngIfLevel] >= 0) {\n            ngIfLevelMap[ngIfLevel]++;\n            // console.log('isPath ngIfCounter', [tagName, ngIfCounter]);\n          }\n        }\n\n        //expand doTA templates with expand=1 option\n        if (attr['dota-render'] && attr.expand) {\n          var attrArray = [];\n          //attach data-X attr, and scope-X attr\n          for(x in attr) {\n            if (!x.indexOf('data-')) {\n              attrArray.push('\"' + x.slice(5) + '\":\"' + attr[x] + '\"');\n            } else if (!x.indexOf('scope-')) {\n              attrArray.push('\"' + x.slice(6) + '\":S[\"' + attr[x] + '\"]');\n            }\n          }\n          FnText += indent(level) + 'var P={' + attrArray.join(',') + '},U=\"' + attr['dota-render'] + '\";\\n';\n          //only expand if renderFn is ready in cache, but not in cache-dom (which unneeded)\n          FnText += indent(level) + 'doTA.C[U]&&!doTA.D[U]&&(R+=doTA.C[U](S,F,P,X)); \\n';\n        }\n\n        level++;\n      },\n\n      //void tag no need to write closing tag\n      voidTag: function() {\n        level--;\n\n        //close \"if\", \"for\", \"while\" blocks\n        //while is needed because loop and if can be in same tag\n        while (LevelMap[level] > 0) {\n          FnText += indent(level, 1) + '}\\n';\n          LevelMap[level]--;\n        }\n\n        //clear ng-repeat $index\n        if (ngRepeatLevel === level) {\n          LevelVarMap[level] = 0;\n          ngRepeatLevel = void 0;\n        }\n\n        //reset dota-pass when out of scope\n        if (doTAPass && doTAPass >= level) {\n          doTAPass = 0;\n        }\n      },\n\n      //close tag\n      closeTag: function(tagName) {\n        level--;\n\n        //just write closing tag back\n        FnText += indent(level) + \"R+='</\" + tagName + \">';\\n\";\n\n        //ngIfCounter for most possible uniqueId generation; don't work with loop inside!\n        if (diffLevel && level === ngIfLevel && ngIfLevelMap[ngIfLevel] >= 0) {\n          // console.log('ngIfLevelMap1', ngIfLevel, ngIfLevels, ngIfLevelMap);\n          if (ngIfLevelMap[ngIfLevel]) {\n            FnText += indent(level, 1) + '}else{N+=' + ngIfLevelMap[ngIfLevel] + '};\\n';\n          }\n          //save counter\n          ngIfCounterTmp = ngIfLevelMap[ngIfLevel];\n          //clear counter\n          ngIfLevelMap[ngIfLevel] = void 0;\n          //remove last level\n          ngIfLevel = ngIfLevels[--ngIfLevels.length - 1];\n          //add up to previous level\n          if (ngIfLevel) {\n            ngIfLevelMap[ngIfLevel] += ngIfCounterTmp;\n          }\n          // console.log('ngIfLevelMap2', ngIfLevel, ngIfLevels, ngIfLevelMap);\n          if (LevelMap[level] > 0) {\n            LevelMap[level]--;\n          }\n        }\n\n        // console.log('LevelMap1', LevelMap);\n        //close \"if\", \"for\", \"while\" blocks\n        while (LevelMap[level] > 0) {\n          FnText += indent(level, 1) + '}\\n';\n          LevelMap[level]--;\n        }\n        // console.log('LevelMap2', LevelMap);\n\n        if (diffLevel) {\n          if (level === ngIfSkipLevel || level === ngRepeatLevel) {\n            // console.log('ngIfLevel', [level, ngIfSkipLevel, ngRepeatLevel])\n            FnText += indent(level, 1) + 'N=O' + level + '; \\n';\n          }\n          if (level === ngIfSkipLevel) {\n            ngIfSkipLevel = void 0;\n          }\n        }\n\n        //clear ng-repeat $index\n        if (ngRepeatLevel === level) {\n          LevelVarMap[level] = 0;\n          ngRepeatLevel = void 0;\n        }\n\n        //add blank node if $watch block return nothing, mostly occur with ng-if\n        if (WatchMap[level]) {\n          FnText += indent(level, 1) +\n            \"R=R||('<\" + tagName + ' id=\"' + idHash[uniqueId + '.' + level] +\n            '\" style=\"display:none\"></' + tagName + '>\\');\\n';\n          WatchMap[level] = 0;\n          FnText += indent(level, 2) + 'return R;}; \\n';\n          FnText += indent(level, 2) + 'R+=W.F(S,F,$attr,X,N); \\n';\n        }\n\n        //reset dota-pass when out of scope\n        if (doTAPass && doTAPass >= level) {\n          doTAPass = 0;\n        }\n      },\n\n      //text node\n      text: function(text) {\n        //console.log([text]);\n        FnText += indent(level) + ('R+=\\'' + interpolate(text) + '\\';\\n')\n          .replace(/\\+''|''\\+/g,'');\n      },\n\n      //comment node\n      comment: function(data) {\n        //console.log(111,[data]);\n        FnText += indent(level) + \"R+='<\" + escapeSingleQuote(data) + \">';\\n\";\n      }\n    });\n\n    if (watchDiff) {\n      FnText += indent(0) + 'if(X&&J in doTA.H){doTA.diff' + (diffLevel || '') + '(J,R)}' +\n        'doTA.H[J]=R;\\n';\n    }\n\n    FnText += indent(0) +'return R;\\n';\n\n    //Default Optimization\n    // - concat possible lines for performance\n    FnText = FnText.replace(/;R\\+=/g,'+').replace(/'\\+'/g,'');\n\n    //extra optimization, which might take some more CPU\n    if (options.optimize && !watchDiff) {\n      FnText = FnText.replace(removeUnneededQuotesRegex,'$1$2');\n    }\n\n    //print the whole function if debug\n    if (options.debug) {\n      /**/console.log(FnText);\n    }\n    // console.log(FnText);\n\n    try {\n      //$scope, $filter\n      compiledFn = new Function('S', 'F', '$attr', 'X', FnText);\n      if (Watched) {\n        compiledFn = {W:[], F: compiledFn};\n      }\n    } catch (err) {\n      if (typeof console !== \"undefined\") {\n        /**/console.log(\"doTA compile error:\\n\" + FnText);\n      }\n      throw err;\n    }\n\n    // just for less array usage on heap profiling\n    // but this may trigger GC more\n    FnText = LevelMap = LevelVarMap = VarMap = ngIfLevels = ngIfLevelMap = WatchMap = void 0;\n    return compiledFn;\n  }\n\n  var compiledHash = {};\n  var lastId = 0;\n\n  function initCompileHash(obj) {\n    for (var x in obj) {\n      compiledHash[x] = obj[x];\n      if (obj[x] > lastId) {\n        lastId = obj[x];\n      }\n    }\n  }\n\n  function getUniqueId(key) {\n    if (key) {\n      if (compiledHash[key]) {\n        return compiledHash[key];\n      } else {\n        compiledHash[key] = lastId;\n        return lastId++;\n      }\n    } else {\n      return lastId++;\n    }\n  }\n\n  var doTAObj = {\n    diff: diffPatchExact,\n    diff2: diffPatchChildren,\n    getId: getUniqueId,\n    initCH: initCompileHash,\n    compile: compileHTML,\n    C: {}, //Cached compiled functions\n    D: {}, //Cached DOM to be used by ngDoTA, needed here to prevent unneccessary rendering\n    H: {} //HashMap for TextDiff\n  };\n\n  //warmup most used functions\n  doTAObj.compile('<div class=\"x {{x}}\" ng-class=\"{x:1}\" ng-repeat=\"x in y\" ng-if=\"x\">x{{x}}</div><!--x-->', {\n    watchDiff: 1, diffLevel: 2});\n\n  return doTAObj;\n})();\n\nif (typeof module !== \"undefined\" && module.exports) {\n  module.exports = doTA;\n//IE8\n} else if (typeof console === \"undefined\") {\n  var noop = function() {};\n  console = {log: noop, time: noop, timeEnd: noop};\n}\n"],"sourceRoot":"/source/"}