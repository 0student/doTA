{"version":3,"sources":["ngDoTA.js"],"names":["doTA","J","k","h","e","a","indexOf","charAt","closeTag","substring","comment","b","c","d","w","q","l","f","n","slice","length","replace","toLowerCase","openTag","voidTag","text","F","setAttribute","document","getElementById","console","log","String","prototype","trim","this","Object","watch","unwatch","R","O","U","V","S","X","P","T","E","Q","C","diff","H","firstChild","nodeType","nodeValue","diff2","y","p","m","createElement","t","lastIndexOf","innerHTML","insertBefore","appendChild","parentNode","removeChild","nextSibling","replaceChild","getId","initCH","compile","match","substr","g","push","D","loose","watchDiff","diffLevel","$index","undefined","$attr","Math","Date","Array","Infinity","NaN","true","false","null","z","dotaRender","L","strip","encode",">","<","v","B","u","G","I","A","M","r","x","N","refresh","elif","exec","test","event","de","value","id","K","expand","join","optimize","debug","Function","W","module","exports","noop","time","timeEnd","forEach","call","split","reduce","splice","assign","apply","arguments","clearTimeout","setTimeout","hidden","attributes","name","removeAttribute","target","srcElement","returnValue","cancelBubble","preventDefault","stopPropagation","$evalAsync","$event","querySelectorAll","getAttribute","type","addEventListener","$applyAsync","documentMode","config","factory","addEvents","addNgModels","directive","restrict","priority","terminal","controller","link","$on","pop","$watchCollection","Z","aa","contentDocument","childNodes","Y","ba","attr","element","$destroy","$new","replaceWith","hasChildNodes","get","cache","success","cacheDom","scope","ngController","model","bind","compileAll","dotaOnload","dotaOnloadScope","loaded","inline","cloneNode","$eval","$scope","controllerAs","data","children","dotaInclude","html","contents","$watch","dotaTemplate","window","angular"],"mappings":"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","file":"ngDoTA.min.js","sourcesContent":["var doTA = (function() {'use strict';\n  /* for ie8 */\n  if (!String.prototype.trim) {\n    String.prototype.trim = function() {\n      return this.replace(/^\\s+|\\s+$/g,'');\n    };\n  }\n\n  /* no, thanks! firefox */\n  if (Object.prototype.watch) {\n    delete Object.prototype.watch;\n    delete Object.prototype.unwatch;\n  }\n\n  // pretty indent for debugging\n  function indent(n, x) {\n    var ret = new Array(n + 2).join('    ');\n    return x ? ret.slice(0, -2 * x) : ret;\n  }\n\n  // decode html entities\n  function decodeEntities(text) {\n    return text.indexOf('&') < 0 ? text : text\n      .replace(/&gt;/g, '>').replace(/&lt;/g, '<')\n      .replace(/&amp;/g, '&').replace(/&quot;/g, '\"');\n  }\n\n  // parse attributes from html open tag and make dict object\n  function parseAttr(chunk, func) {\n    var attr = {}, tagName;\n    var pos = chunk.indexOf(' ');\n    var len, attrName, attrVal;\n    var valStart, valEndPos;\n\n    if (pos !== -1) {\n      tagName = chunk.slice(0, pos);\n      len = chunk.length;\n\n      //console.log(222, [pos, chunk]);\n      while (++pos < len) {\n        var eqPos = chunk.indexOf('=', pos);\n\n        // ** attribute without value (last attribute) **\n        if (eqPos === -1) {\n          attrName = chunk.slice(pos);\n          // console.log('eqPos === -1', [attrName, pos, chunk])\n          if (attrName !== '/') {\n            attr[attrName] = '';\n          }\n          //attr required will be required=\"\", while is valid syntax\n          //http://www.w3.org/TR/html-markup/syntax.html#syntax-attr-empty\n          break;\n        }\n\n        // uncomment this if you need no value attribute in the middle\n        // ** attribute without value (middle attribute) **\n        // var sp_pos = chunk.indexOf(' ', pos);\n        // if (sp_pos > 0 && sp_pos < eqPos) {\n        //   attr[chunk.slice(pos, sp_pos)] = \"\";\n        //   pos = sp_pos;\n        //   continue;\n        // }\n\n        //console.log(33, [eqPos]);\n        attrName = chunk.slice(pos, eqPos);\n        //console.log(331, [attrName]);\n\n        valStart = chunk[eqPos + 1];\n        //console.log(332, [valStart]);\n\n        //if attribute value is start with quote\n        if (valStart === '\"' || valStart === \"'\") {\n          valEndPos = chunk.indexOf(valStart, eqPos + 2);\n          if (valEndPos < 0) { throw 'ERR:Invalid HTML: [' + chunk + ']'; }\n\n          attrVal =  chunk.slice(eqPos + 2, valEndPos);\n          attr[attrName] =0>attrVal.indexOf(\"&\")?attrVal:attrVal.replace(/&gt;/g,\">\").replace(/&lt;/g,\"<\").replace(/&amp;/g,\"&\").replace(/&quot;/g,'\"'); //INLINE;\n          pos = valEndPos + 1;\n          //console.log(311, [valEndPos, attrName, attrVal]);\n        } else {\n\n          valEndPos = chunk.indexOf(' ', eqPos + 2);\n\n          //when no more attributes\n          if (valEndPos < 0) {\n            attrVal =  chunk.slice(eqPos + 1);\n            attr[attrName] =0>attrVal.indexOf(\"&\")?attrVal:attrVal.replace(/&gt;/g,\">\").replace(/&lt;/g,\"<\").replace(/&amp;/g,\"&\").replace(/&quot;/g,'\"'); //INLINE;\n            //console.log(442, [attrVal]);\n            break;\n\n          } else {\n            attrVal =  chunk.slice(eqPos + 1, valEndPos);\n            attr[attrName] =0>attrVal.indexOf(\"&\")?attrVal:attrVal.replace(/&gt;/g,\">\").replace(/&lt;/g,\"<\").replace(/&amp;/g,\"&\").replace(/&quot;/g,'\"'); //INLINE;\n            //console.log(313, [eqPos, valEndPos, attrVal]);\n            pos = valEndPos;\n          }\n        }\n      }\n\n      tagName = tagName.toLowerCase();\n      if (tagName === 'input' || tagName === 'img') {\n        //http://www.w3.org/TR/html-markup/syntax.html\n        //area, base, br, col, command, embed, hr, img, input, keygen, link, meta, param, source, track, wbr\n        func.openTag(tagName, attr, 1);\n        func.voidTag();\n      } else if (attrName === '/') {\n        func.openTag(tagName, attr);\n        func.closeTag(tagName);\n      } else {\n        func.openTag(tagName, attr);\n      }\n\n    // no attributes\n    } else {\n\n      // self closing, explicit\n      if (chunk.charAt(chunk.length - 1) === '/') {\n        tagName = chunk.slice(0, -1).toLowerCase();\n\n        if (tagName === 'br' || tagName === 'hr') {\n          func.openTag(tagName, attr, 1);\n          func.voidTag();\n        } else {\n          func.openTag(tagName, attr);\n          func.closeTag(tagName);\n        }\n      } else {\n        tagName = chunk.toLowerCase();\n\n        // self closing, implicit\n        if (tagName === 'br' || tagName === 'hr') {\n          func.openTag(tagName, attr, 1);\n          func.voidTag();\n        } else {\n          func.openTag(tagName, attr);\n        }\n      }\n    }\n\n  }\n\n  var events = ' change click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste ';\n  var valid_chr = '_$abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n\n  // minimal stripped down html parser\n  function parseHTML(html, func) {\n    if (!html) { return; }\n    var prevPos = 0, pos = html.indexOf('<');\n    do {\n      if (html.charAt(pos) === '<') {\n        pos++;\n        if (html.charAt(pos) === '/') {\n          prevPos = ++pos;\n          pos = html.indexOf('>', prevPos);\n          //close tag must be like </div>, but not <div />\n          // console.log(['closetag', prevPos, pos, html.substring(prevPos, pos)])\n          func.closeTag(html.substring(prevPos, pos));\n        } else if (html.charAt(pos) === '!') {\n          prevPos = pos;\n          pos = html.indexOf('>', prevPos);\n          // console.log(['comment', prevPos, pos, html.substring(prevPos, pos)])\n          func.comment(html.substring(prevPos, pos));\n        } else {\n          prevPos = pos;\n          pos = html.indexOf('>', prevPos);\n          // console.log(['opentag', prevPos, pos, html.substring(prevPos, pos), parseAttr(html.substring(prevPos, pos))])\n          // func.openTag.apply(this, parseAttr(html.substring(prevPos, pos)));\n          parseAttr(html.substring(prevPos, pos), func);\n        }\n      } else if (html.charAt(pos) === '>') { //&& html.charAt(pos + 1) !== '<'\n        prevPos = ++pos;\n        pos = html.indexOf('<', prevPos);\n        if (pos > prevPos) {\n          // console.log(['text', prevPos, pos, html.substring(prevPos, pos)])\n          func.text(html.substring(prevPos, pos));\n        }\n      } else {\n        console.error('Parse ERR?', [prevPos, pos, html.substring(prevPos, pos), html.slice(pos)]);\n        break;\n      }\n\n    } while (pos > 0);\n  }\n\n  //diff and patch dom with exact same structure\n  function diffPatchExact(prevKey, html2) {\n    var html1 = doTA.H[prevKey];\n    var prevPos1 = 0, pos1 = html1.indexOf('<');\n    var prevPos2 = 0, pos2 = html2.indexOf('<');\n    var tagId = '', elem, part1, part2;\n    var posx, endPosx;\n\n    do {\n      if (html1.charAt(pos1) === \"<\") {\n        pos1++;\n        pos2++;\n        if (html1.charAt(pos1) === \"/\" || html1.charAt(pos1) === \"!\") {\n          //don't patch comment node and close tag.\n          pos1 = html1.indexOf('>', pos1);\n          pos2 = html2.indexOf('>', pos2);\n        } else {\n          prevPos1 = pos1;\n          prevPos2 = pos2;\n          pos1 = html1.indexOf('>', prevPos1);\n          pos2 = html2.indexOf('>', prevPos2);\n          part1 = html1.substring(prevPos1, pos1);\n          part2 = html2.substring(prevPos2, pos2);\n          //attributes\n          if (part1 !== part2) {\n            // console.log('openTag', [part1, part2])\n            tagId = parsePatchAttr(part1, part2);\n          } else {\n            //record id\n            //tagId = getTagId(part1);\n            posx = part1.indexOf(' id=\"');\n            0 <= posx && (posx += 5, endPosx = part1.indexOf('\"', posx), tagId = part1.substring(posx, endPosx));\n          }\n        }\n\n      //text node\n      } else if (html1.charAt(pos1) === '>') {\n        prevPos1 = ++pos1;\n        prevPos2 = ++pos2;\n\n        pos1 = html1.indexOf('<', prevPos1);\n        pos2 = html2.indexOf('<', prevPos2);\n        //textNode, only support firstChild here\n        if (pos2 > prevPos2) {\n          var text1 = html1.substring(prevPos1, pos1);\n          var text2 = html2.substring(prevPos2, pos2);\n          if (text1 !== text2) {\n            elem = document.getElementById(tagId);\n            if (elem) {\n              if (elem.firstChild && elem.firstChild.nodeType === 3) {\n                // console.log('textApplied', [text1, text2]);\n                elem.firstChild.nodeValue = text2;\n              } //else to log something?\n            } else {\n              console.log('tag not found', [tagId]);\n            }\n          }\n        }\n\n      }\n\n    } while(pos1 > 0);\n  }\n\n  // find position of outerHTML end\n  // this function will be inline during building\n  function getOuterHTMLEnd(HTML, START_POS) {\n    var LVL = 1, POS = START_POS;\n    do {\n      POS = HTML.indexOf('<', POS + 1);\n      if (HTML.charAt(POS + 1) === '/') {\n        LVL--;\n      } else {\n        LVL++;\n      }\n      POS = HTML.indexOf('>', POS);\n      if (HTML.charAt(POS - 1) === '/') { //self closing\n        LVL--;\n      }\n    } while (LVL > 0);\n\n    // console.log('getOutHTML', tagName, [tagName, pos2, pos2, ])\n    return ++POS;\n  }\n\n  // FlatDOM: diff html as text and patch dom nodes\n  function diffPatchChildren(prevKey, html2) {\n    var html1 = doTA.H[prevKey];\n    var prevPos1 = 0, pos1 = html1.indexOf('<');\n    var prevPos2 = 0, pos2 = html2.indexOf('<');\n    var tagId1, tagId2, elem1, elem2, part1, part2;\n    var tagNo1 = 0, tagNo2 = 0;\n    var newNode = document.createElement('div');\n    var parentNode, nextSibling;\n    var tagStartPos1, tagStartPos2;\n    var dirty1 = 0, dirty2 = 0;\n    var prevTagId2;\n    var LVL; //this is needed for fnInline\n    // console.log(html1);\n    // console.log(html2);\n\n    for(;;) {\n      // console.log('before', [dirty1, dirty2], [tagId1, tagId2], [html1.substr(pos1, 20), html2.substr(pos2, 20)]);\n\n      if (pos1 >= 0 && dirty2 < 2) {\n        prevPos1 = pos1;\n        pos1 = html1.indexOf(' id=\"', prevPos1);\n        if (pos1 > 0) {\n          prevPos1 = pos1 + 5;\n          pos1 = html1.indexOf('\"', prevPos1);\n          tagId1 = html1.substring(prevPos1, pos1);\n          tagNo1 = tagId1^0;\n        }\n        if (dirty2 && tagNo1 > tagNo2) {\n          dirty2 = 2;\n        }\n      }\n\n      // console.log('middle', [tagId1, tagId2], [html1.substr(pos1, 20), html2.substr(pos2, 20)]);\n\n      if (pos2 >= 0 && dirty1 < 2) {\n        prevTagId2 = tagId2;\n        prevPos2 = pos2;\n        pos2 = html2.indexOf(' id=\"', prevPos2);\n        if (pos2 > 0) {\n          prevPos2 = pos2 + 5;\n          pos2 = html2.indexOf('\"', prevPos2);\n          tagId2 = html2.substring(prevPos2, pos2);\n          tagNo2 = tagId2^0;\n        }\n        if (dirty1 && tagNo2 > tagNo1) {\n          dirty1 = 2;\n        }\n      }\n\n      // console.log('after', [dirty1, dirty2], [tagId1, tagId2],\n      //   [pos1, pos2], [html1.substr(pos1, 20), html2.substr(pos2, 20)]);\n\n      if (pos1 < 0 && pos2 < 0) break;\n\n      if (pos1 > 0 && pos2 > 0) {\n        if (tagNo1 === tagNo2) {\n          //attr diff\n          tagStartPos1 = ++pos1;\n          pos1 = html1.indexOf('>', pos1);\n          part1 = html1.substring(tagStartPos1, pos1);\n\n          tagStartPos2 = ++pos2;\n          pos2 = html2.indexOf('>', pos2);\n          part2 = html2.substring(tagStartPos2, pos2);\n\n          if (part1 !== part2) {\n            elem1 = document.getElementById(tagId1);\n            parsePatchAttr(part1, part2, elem1);\n            // console.warn('patch node', [tagId1, tagId2], [pos1, pos2], [tagStartPos1, tagStartPos2], [part1, part2])\n          } else {\n            elem1 = 0;\n          }\n\n          //text diff\n          prevPos1 = ++pos1;\n          pos1 = html1.indexOf('<', prevPos1);\n          part1 = html1.substring(prevPos1, pos1);\n          prevPos2 = ++pos2;\n          pos2 = html2.indexOf('<', prevPos2);\n          part2 = html2.substring(prevPos2, pos2);\n          if (part1 !== part2) {\n            if (!elem1) {\n              elem1 = document.getElementById(tagId1);\n            }\n            if (elem1.firstChild && elem1.firstChild.nodeType === 3) {\n              elem1.firstChild.nodeValue = part2;\n            }\n            // console.warn('patch text node', [tagId1, tagId2], [part1, part2])\n          }\n          dirty1 = dirty2 = 0;\n          continue;\n        }\n      }\n\n      if (dirty1 && ((tagNo1 > tagNo2 && pos2 > 0) || pos1 < 0)) {\n        // console.warn('dirty1**', [dirty1, dirty2], [tagNo1, tagNo2]);\n        dirty2 = 2;\n        dirty1 = 0;\n      }\n      if (dirty2 && ((tagNo2 > tagNo1 && pos1 > 0) || pos2 < 0)) {\n        // console.warn('dirty2**', [dirty1, dirty2], [tagNo1, tagNo2]);\n        dirty1 = 2;\n        dirty2 = 0;\n      }\n\n      if (dirty2 && (tagNo1 > tagNo2 || (pos1 < 0 && pos2 > 0))) {\n        // console.log('dirty2', [tagNo1, tagNo2]);\n        tagStartPos2 = html2.lastIndexOf('<', pos2 - 6);\n        LVL=1,pos2=tagStartPos2;do pos2=html2.indexOf(\"<\",pos2+1),\"/\"===html2.charAt(pos2+1)?LVL--:LVL++,pos2=html2.indexOf(\">\",pos2),\"/\"===html2.charAt(pos2-1)&&LVL--;while(0<LVL);++pos2; //INLINE\n\n        newNode.innerHTML = html2.slice(tagStartPos2, pos2);\n        // console.log('newNode', [tagId1, tagId2, prevTagId2], newNode.innerHTML, nextSibling, parentNode);\n        if (parentNode) {\n          if (nextSibling) {\n            elem2 = parentNode.insertBefore(newNode.firstChild, nextSibling);\n          } else {\n            parentNode.appendChild(newNode.firstChild);\n          }\n        } else {\n          parentNode = document.getElementById(prevTagId2);\n          parentNode.appendChild(newNode.firstChild);\n        }\n        // console.warn('add node', [tagNo1, tagNo2], elem2);\n        continue;\n      }\n\n      if (dirty1 && (tagNo2 > tagNo1 || (pos2 < 0 && pos1 > 0))) {\n        // console.log('dirty1', [tagId1, tagId2]);\n        elem1 = document.getElementById(tagId1);\n        elem1.parentNode.removeChild(elem1);\n        //skip\n        LVL=1,pos1=pos1;do pos1=html1.indexOf(\"<\",pos1+1),\"/\"===html1.charAt(pos1+1)?LVL--:LVL++,pos1=html1.indexOf(\">\",pos1),\"/\"===html1.charAt(pos1-1)&&LVL--;while(0<LVL);++pos1; //INLINE\n        // console.warn('removeChild', [tagNo1, tagNo2], elem1, [html1.substr(pos1, 15)]);\n        continue;\n      }\n\n      if (pos1 > 0 && pos2 > 0) {\n        if (tagNo1 !== tagNo2 && !dirty2 && !dirty1) {\n          // console.log('before delete', [tagId1, tagId2]);\n          elem1 = document.getElementById(tagId1);\n          nextSibling = elem1.nextSibling;\n          parentNode = elem1.parentNode;\n\n          tagStartPos2 = html2.lastIndexOf('<', pos2 - 6);\n          LVL=1,pos2=tagStartPos2;do pos2=html2.indexOf(\"<\",pos2+1),\"/\"===html2.charAt(pos2+1)?LVL--:LVL++,pos2=html2.indexOf(\">\",pos2),\"/\"===html2.charAt(pos2-1)&&LVL--;while(0<LVL);++pos2; //INLINE\n          newNode.innerHTML = html2.substring(tagStartPos2, pos2);\n          parentNode.replaceChild(newNode.firstChild, elem1);\n\n          LVL=1,pos1=pos1;do pos1=html1.indexOf(\"<\",pos1+1),\"/\"===html1.charAt(pos1+1)?LVL--:LVL++,pos1=html1.indexOf(\">\",pos1),\"/\"===html1.charAt(pos1-1)&&LVL--;while(0<LVL);++pos1; //INLINE\n          // console.log( [pos1, newPos],[html1.substring(pos1, newPos)]);\n          // console.warn('replaced node', [tagId1, tagId2], [tagNo1, tagNo2], elem1);\n          if (tagNo1 < tagNo2) dirty2 = 1;\n          if (tagNo1 > tagNo2) dirty1 = 1;\n        }\n      }\n\n    } //infinite loop\n\n  }\n\n  // parse attributes from html open tag and patch DOM when different\n  function parsePatchAttr(chunk1, chunk2, elem) {\n    var tagId;\n    var pos1 = chunk1.indexOf(' ');\n    var eqPos1, eqPos2;\n    var valEndPos1, valEndPos2, posDiff = 0;\n    var attrName, attrVal1, attrVal2;\n    var len1 = chunk1.length;\n    // console.log('chunks', [chunk1, chunk2]);\n    if (pos1 !== -1) {\n      while (++pos1 < len1) {\n        eqPos1 = chunk1.indexOf('=\"', pos1);\n        if (eqPos1 < 0) break;\n        attrName = chunk1.slice(pos1, eqPos1);\n\n        valEndPos1 = chunk1.indexOf('\"', eqPos1 + 2);\n        attrVal1 =  chunk1.slice(eqPos1 + 2, valEndPos1);\n        if (!elem && attrName === 'id') {\n          tagId = attrVal1;\n          elem = document.getElementById(tagId);\n          if (!elem) {\n            return console.log('tag not found', [tagId]);\n          }\n        } else {\n          eqPos2 = eqPos1 + posDiff;\n          valEndPos2 = chunk2.indexOf('\"', eqPos2 + 2);\n          attrVal2 =  chunk2.slice(eqPos2 + 2, valEndPos2);\n          posDiff = valEndPos2 - valEndPos1;\n          if (attrVal1 !== attrVal2) {\n            // console.log('setAttribute', [attrName, attrVal1, attrVal2], [chunk1, chunk2])\n            elem.setAttribute(attrName, attrVal2);\n          }\n        }\n        pos1 = valEndPos1 + 1;\n\n      } //while\n    }\n    return tagId;\n  }\n\n  // extract value of id from part of html open tag\n  // only id=\"xxx\" supported, this is internal use, so it's always double-quotes\n  // this function is inlined during building\n  function getTagId(partial, start) {\n    var pos = partial.indexOf(' id=\"', start), endPos;\n    if (pos >= 0) {\n      pos += 5;\n      endPos = partial.indexOf('\"', pos);\n      return partial.substring(pos, endPos);\n    }\n  }\n\n  // split filters into array, take care of | and || as different\n  function splitFilters(input) {\n    var pos = input.indexOf('|');\n    if (pos === -1) {\n      return [input];\n    }\n    var prevPos = 0;\n    var ret = [];\n    while (pos !== -1) {\n      if (input.charAt(pos + 1) === '|') {\n        pos += 2;\n      } else {\n        ret.push(input.substring(prevPos, pos));\n        prevPos = ++pos;\n      }\n      pos = input.indexOf('|', pos);\n    }\n    if (prevPos < input.length) {\n      ret.push(input.substr(prevPos));\n    }\n    return ret;\n  }\n\n  // ToDo: check compile performance with regex\n  var ngClassRegex = /('[^']+'|\"[^\"]+\"|[\\w$]+)\\s*:\\s*((?:[$.\\w]+|\\([^)]+\\)|[^},])+)/g;\n  var varOrStringRegex = /'[^']*'|\"[^\"]*\"|[\\w$]+|[^\\w$'\"]+/g;\n  var quotedStringRegex = /\"[^\"]*\"|'[^']*'/g;\n  var whiteSpaceRegex = /\\s{2,}|\\n/g;\n  var removeUnneededQuotesRegex = /\\b([\\w_-]+=)\"([^\"'\\s]+)\"(?=[\\s>])/g;\n  var lazyNgAttrRegex = /^(?:src|alt|title|href)/;\n  // https://github.com/kangax/html-minifier/issues/63\n  var noValAttrRegex = /^(?:checked|selected|disabled|readonly|multiple|required|hidden|nowrap)/;\n  var $indexRegex = /\\$index/g;\n\n  // exported as doTA.compile\n  function compileHTML(template, options) {\n    options = options || {};\n    var val_mod = options.loose ? \"||''\" : '';\n    var isPatch = options.watchDiff;\n    var diffLevel = +options.diffLevel;\n    var VarMap = {$index: 1, undefined: 1, $attr: 1,\n      Math: 1, Date: 1, String: 1, Object: 1, Array: 1, Infinity: 1, NaN: 1,\n      true: 1, false: 1, null: 1};\n    var level = 0, lastLevel, ngIfLevel, ngIfCounter;\n    var LevelMap = {}, LevelVarMap = {};\n    var WatchMap = {}, Watched;\n    var doTAPass, doTAContinue;\n    var compiledFn;\n    var uniqueId = this.getId(options.dotaRender);\n    var idHash = {};\n\n    var FnText = indent(level) + \"'use strict';var \" +\n      (isPatch ? 'N=1,J=' + uniqueId + ',' : '') +\n      \"R='';\\n\"; //ToDO: check performance on var declaration\n\n    //clean up extra white spaces and line break\n    template = template.replace(whiteSpaceRegex, ' ');\n\n    if (options.strip) {\n      template = template.replace(/>\\s+/g, '>').replace(/\\s+</g, '<');\n    }\n\n    // when encode is set, find strings and encode < and >, or parser will throw error.\n    if (options.encode) {\n      template = template.replace(quotedStringRegex, function($0) {\n        return $0.replace(/[<>]/g, function($00) {\n          return {'>': '&gt;', '<': '&lt;'}[$00];\n        });\n      });\n    }\n\n    // attach plain variables to scope variables\n    function attachScope(v) {\n      //console.log(VarMap, [v]);\n      if (v) {\n        //var DEBUG = /error/.test(v);\n        //DEBUG && console.log(11, [v]);\n\n        //ToDo: still buggy, this need to improve\n        var vv = '';\n        var matches = v.match(varOrStringRegex);\n        //DEBUG && console.log(12, matches);\n        for(var i = 0; i < matches.length; i++) {\n\n          if (valid_chr.indexOf(matches[i].charAt(0)) >= 0 && !VarMap[matches[i]] &&\n            (!i || matches[i-1][matches[i-1].length-1] !== '.')) {\n            vv += 'S.' + matches[i];\n          } else {\n            if (matches[i].indexOf('$index') >= 0) {\n              //console.log([val], LevelMap[level]);\n              //for(var j = level; j >= 0; j--) {\n              //  if (LevelVarMap[j]) {\n                  vv += matches[i].replace($indexRegex, LevelVarMap[lastLevel]);\n                  //break;\n                //}\n              //}\n            } else {\n              vv += matches[i];\n            }\n          }\n        }\n        //DEBUG && console.log(55, vv);\n        return vv;\n      }\n      return v;\n    }\n\n    // escape single quotes with backslash\n    function escapeSingleQuote(str) {\n      var quotePos = str.indexOf(\"'\");\n      if (quotePos >= 0) {\n        var ret = '';\n        var prevQuotePos = 0;\n        do {\n          ret += str.substring(prevQuotePos, quotePos);\n          //escaped quote\n          if (str.charAt(quotePos - 1) !== '\\\\') {\n            ret += \"\\\\\";\n          }\n          prevQuotePos = quotePos;\n          quotePos = str.indexOf(\"'\", prevQuotePos + 1);\n        } while (quotePos > 0);\n        ret += str.substr(prevQuotePos);\n        return ret;\n      } else {\n        return str;\n      }\n    }\n\n    // interpolation\n    function interpolate(str) {\n      var pos = str.indexOf('{{');\n      if (pos >= 0) {\n        var prevPos = 0;\n        var ret = '';\n        var outsideStr, insideStr;\n        do {\n          outsideStr = str.substring(prevPos, pos);\n          ret += escapeSingleQuote(outsideStr);\n\n          //skip {{\n          prevPos = pos + 2;\n          pos = str.indexOf('}}', prevPos);\n\n          insideStr = str.substring(prevPos, pos);\n          ret += \"'+(\" + attachFilter(insideStr) + val_mod + \")+'\";\n\n          //skip }} for next\n          prevPos = pos + 2;\n          pos = str.indexOf('{{', prevPos);\n        } while (pos > 0);\n\n        //remaining text outside interpolation\n        ret += escapeSingleQuote(str.substr(prevPos));\n        return ret;\n      } else {\n        return escapeSingleQuote(str);\n      }\n    }\n\n    // attach $filters\n    function attachFilter($1) {\n      //console.log(333,$1);\n      var pos = $1.indexOf('|');\n      if (pos === -1) {\n        return attachScope($1);\n      } else {\n        //ToDo: check this line later\n        var v = splitFilters($1);\n        var val = attachScope(v[0]);\n        var prevColonPos = 0, colonPos;\n        var filter;\n\n        //parse each filters\n        for(var i = 1; i < v.length; i++) {\n          filter = v[i];\n\n          colonPos = filter.indexOf(':');\n          //filter with params\n          if (colonPos > 0) {\n            val = \"F('\" + filter.slice(prevColonPos, colonPos).trim() + \"')(\" + val;\n            prevColonPos = ++colonPos;\n            colonPos = filter.indexOf(':', prevColonPos);\n            while (colonPos > 0) {\n              val += ',' + attachScope(filter.slice(prevColonPos, colonPos));\n              prevColonPos = ++colonPos;\n              colonPos = filter.indexOf(':', prevColonPos);\n            }\n            val += ',' + attachScope(filter.substr(prevColonPos)) + ')';\n\n          //filter without params\n          } else {\n            val = \"F('\" + filter.trim() + \"')(\" + val + ')';\n          }\n\n        }\n        return val;\n      }\n    }\n\n    //parse the element\n    parseHTML(template, {\n      //open tag with attributes\n      openTag: function(tagName, attr, selfClosing) {\n        // debug && console.log('openTag', [tagName, attr]);\n        var interpolatedAttr = {}, customId, tagId, noValAttr = '', attrName, attrVal, oneTimeBinding;\n\n        //skip parsing ng-if, ng-repeat, ng-class with, dota\n        // but interpolation will still be evaluated (by-design)\n        // to avoid this behavior, use ng-bind instead of {{}}\n        //  and create new scope with scope=1 in dota-render, or $watchers will never destroy.\n        if (attr['dota-pass']) {\n          doTAPass = level; doTAContinue = 0;\n        //re-enable dota parsing\n        } else if (attr['dota-continue']) {\n          doTAContinue = level;\n        }\n\n        //unless dota-pass or with dota-continue\n        if (!doTAPass || doTAContinue) {\n          //ng-repeat to while/for loop\n          if (attr['ng-repeat']) {\n            //console.log(21,[x], [val]);\n            LevelMap[level] = LevelMap[level] ? LevelMap[level] + 1 : 1;\n            var idx = 'i' + level, l = 'l'+ level;\n            var NG_REPEAT = attr['ng-repeat'];\n            var inPos = NG_REPEAT.indexOf(' in ');\n            var repeatVar = NG_REPEAT.substr(0, inPos), repeatSrc = NG_REPEAT.substr(inPos + 4);\n            var commaPos = repeatVar.indexOf(',');\n            var pipePos = repeatSrc.indexOf('|'), repeatSrcNew;\n            var colonPos, x;\n\n            //store variable name to use for $index later\n            //this is ng-repeat specific, LevelMap[level] is same for ng-if too\n            LevelVarMap[level] = idx;\n            lastLevel = level;\n\n            if (pipePos > 0) {\n              repeatSrcNew = attachFilter(repeatSrc);\n            } else {\n              colonPos = repeatSrc.indexOf(':');\n              if (colonPos < 0) {\n                repeatSrcNew = attachScope(repeatSrc);\n              }\n            }\n\n            // Range: \"i in 1:10\" ==> (for i = 1; i < 10; i++)\n            if (colonPos > 0) {\n              var start = repeatSrc.substr(0, colonPos), end, step;\n              var anotherColon = repeatSrc.indexOf(':', ++colonPos);\n              if (anotherColon > 0) {\n                end = repeatSrc.substring(colonPos, anotherColon);\n                step = repeatSrc.substr(anotherColon + 1);\n              } else {\n                end = repeatSrc.substr(colonPos);\n                step = 1;\n              }\n              // console.log([start, end, step])\n\n              FnText += indent(level, 1) + 'for(var ' + repeatVar + '=' + start + ';' +\n                repeatVar + (step > 0 ? '<' : '>') + end + ';' + repeatVar + '+=' + step + '){\\n';\n              VarMap[repeatVar] = 1;\n\n            // Object: \"k, v in {}\" ==> (for in {})\n            } else if (commaPos > 0) {\n              var key = repeatVar.substr(0, commaPos);\n              var value = repeatVar.substr(commaPos + 1);\n              FnText += indent(level, 1) + 'var ' + value + ',D' + level + '=' + repeatSrcNew + ';\\n';\n              FnText += indent(level, 1) + 'for(var ' + key + ' in D' + level + '){\\n';\n              //                             space is needed for manual uglify  ->  vvv\n              FnText += indent(level) + value + ' = ' + 'D' + level + '[' + key + ']; \\n';\n              VarMap[key] = VarMap[value] = 1;\n\n            // Array: \"k in []\" ==> while loop\n            } else {\n              FnText += indent(level, 1) + 'var ' + repeatVar + ',D' + level + '=' + repeatSrcNew + ','\n                + idx + '=-1,' + l + '=D' + level + '.length;\\n';\n              FnText += indent(level, 1) + 'while(++' + idx + '<' + l + '){\\n';\n              //                        space is needed for manual uglify  ->  vvv\n              FnText += indent(level) + repeatVar + '=D' + level + '[' + idx + ']; \\n';\n              VarMap[repeatVar] = 1;\n            }\n            //remote attribute not to get forwarded to angular\n            delete attr['ng-repeat'];\n          }\n\n          if (attr.refresh) {\n            customId = 1;\n            oneTimeBinding = attr.refresh.indexOf('::');\n            FnText += indent(level, 2) +\n              (!Watched ? 'var ' + (isPatch ? '': 'N=1,') + 'T=this;T.W=[];' : '') +\n              'var W={N:N,I:N+\"' + '.' + uniqueId + '\",W:\"' +\n              (oneTimeBinding >=0 ? attr.refresh.substr(oneTimeBinding + 2) + '\",O:1': attr.refresh + '\"') +\n              (attr.compile ? ',C:1' : '') +\n              '};T.W.push(W);\\n';\n            WatchMap[level] = Watched = 1;\n            FnText += indent(level, 2) + 'W.F=function(S,F,$attr,X,N){var R=\"\";\\n';\n            attr.refresh = void 0;\n          }\n\n          //ng-if to javascript if\n          if (attr['ng-if']) {\n            LevelMap[level] = LevelMap[level] ? LevelMap[level] + 1 : 1;\n            FnText += indent(level, 1) + 'if('+ attachScope(attr['ng-if']) +'){\\n';\n\n            if (diffLevel) {\n              ngIfLevel = level;\n              ngIfCounter = 0;\n            }\n            // console.log('ng-if starts here', level);\n            attr['ng-if'] = void 0;\n          }\n\n          if (attr['elif'] !== void 0) {\n            FnText += indent(level, 1) + 'else if('+ attachScope(attr['elif']) +'){\\n';\n            LevelMap[level] = LevelMap[level] ? LevelMap[level] + 1 : 1;\n            attr['elif'] = void 0;\n          }\n\n          if (attr['else'] !== void 0 && !isPatch) {\n            FnText += indent(level, 1) + 'else{\\n';\n            LevelMap[level] = LevelMap[level] ? LevelMap[level] + 1 : 1;\n            attr['else'] = void 0;\n          }\n\n          if (attr['ng-init']) {\n            FnText += indent(level) + attachScope(attr[\"ng-init\"]) + '; \\n';\n            attr['ng-init'] = void 0;\n          }\n\n          if (attr['ng-class']) {\n            var ngScopedClass = attachScope(attr['ng-class']), match;\n            interpolatedAttr.class = (attr.class ? interpolate(attr.class) : '');\n            while((match = ngClassRegex.exec(ngScopedClass)) !== null) {\n              interpolatedAttr.class +=\n                (\"'+(\" + match[2] + '?' +\n                  \"'\" + (interpolatedAttr.class ? ' ' : '') + match[1].replace(/['\"]/g, '') +\n                  \"':'')+'\");\n            }\n            attr['ng-class'] = void 0;\n          }\n\n          if (attr['ng-show']) {\n            interpolatedAttr.class = (interpolatedAttr.class || attr.class || '');\n            interpolatedAttr.class += \"'+(\" + attachScope(attr['ng-show']) +\n              \"?'':'\" + (interpolatedAttr.class ? ' ' : '') + \"ng-hide')+'\";\n            attr['ng-show'] = void 0;\n          }\n\n          if (attr['ng-hide']) {\n            interpolatedAttr.class = (interpolatedAttr.class || attr.class || '');\n            interpolatedAttr.class += \"'+(\" + attachScope(attr['ng-hide']) +\n              \"?'\" + (interpolatedAttr.class ? ' ' : '') + \"ng-hide':'')+'\";\n            attr['ng-hide'] = void 0;\n          }\n\n          //remove +''+ from class, for unnecessary string concat\n          if (interpolatedAttr.class) {\n            interpolatedAttr.class = interpolatedAttr.class.replace(/\\+''\\+/g, '+');\n            attr.class = void 0;\n          }\n\n          // expand interpolations on attributes, and some more\n          for (x in attr) {\n            attrVal = attr[x];\n            if (attrVal === void 0) { continue; }\n\n            // some ng- attributes\n            if (x.substr(0, 3) === 'ng-') {\n              //some ng-attr are just don't need it here.\n              attrName = x.substr(3);\n              //something like ng-src, ng-href, etc.\n              if (lazyNgAttrRegex.test(attrName)) {\n                x = attrName;\n\n              //convert ng-events to dota-events, to be bind later with native events\n              } else if (options.event && events.indexOf(' ' + attrName + ' ') >= 0) {\n                //adding attr \"de\" for querySelectorAll in ngDoTA\n                interpolatedAttr.de = '1'; //dota-event\n                x = 'de-' + attrName;\n\n              } else if (noValAttrRegex.test(attrName)) {\n                noValAttr += \"'+(\" + attachScope(attrVal) + \"?' \" + attrName + \"=\\\"\\\"':'')+'\";\n                //noValAttr will attach later\n                continue;\n\n              //ng-value\n              } else if (attrName === 'value') {\n                interpolatedAttr.value = \"'+(\" + attachScope(attrVal) + \")+'\";\n                continue;\n              }\n            }\n\n            //ng-repeat loop variables are not available!\n            // only way to acccess is to use $index like \"data[$index]\"\n            // instead of \"item\" as in \"item in data\"\n            if (attrVal.indexOf('$index') >= 0) {\n              //console.log([val], LevelMap[level]);\n              //for(var j = level; j >= 0; j--) {\n              //  if (LevelVarMap[j]) {\n                  interpolatedAttr[x] = interpolate(attrVal).replace($indexRegex, \"'+\" + LevelVarMap[lastLevel] + \"+'\");\n              //    break;\n              //  }\n              //}\n            } else {\n              interpolatedAttr[x] = interpolate(attrVal);\n            }\n          }\n\n        // pass all attributes to angular, except interpolation and $index\n        } else {\n          for (x in attr) {\n            //or just do use escapeSingleQuote\n\n            if (attr[x].indexOf('$index') >= 0) {\n              //console.log([val], LevelMap[level]);\n              //for(var j = level; j >= 0; j--) {\n              //  if (LevelVarMap[j]) {\n                  interpolatedAttr[x] = interpolate(attr[x]).replace($indexRegex, \"'+\" + LevelVarMap[lastLevel] + \"+'\");\n              //    break;\n              //  }\n              //}\n            } else {\n              interpolatedAttr[x] = interpolate(attr[x]);\n            }\n          }\n        }\n\n        //write tag back as string\n        FnText += indent(level) + \"R+='<\" + tagName;\n\n        //make id attr come before anything\n        if (customId || isPatch) {\n          tagId = idHash[uniqueId + '.' + level] = interpolatedAttr.id || (\"'+(N++)+'.\" + uniqueId);\n          FnText += ' id=\"' + tagId + '\"';\n          if (interpolatedAttr.id) {\n            interpolatedAttr.id = void 0;\n          }\n        }\n\n        //write back attributes\n        for(var k in interpolatedAttr) {\n          FnText += \" \" + k + '=\"' + interpolatedAttr[k] + '\"';\n        }\n\n        //attach boolean attributes at last\n        FnText += noValAttr +  (selfClosing ? ' /' : '') + \">';\\n\";\n\n        if (isPatch) {\n          // FnText += indent(level) + \"N++; \\n\";\n          if (ngIfCounter >= 0) {\n            ngIfCounter++;\n            // console.log('isPath ngIfCounter', [tagName, ngIfCounter]);\n          }\n        }\n\n        //expand doTA templates with expand=1 option\n        if (attr['dota-render'] && attr.expand) {\n          var attrArray = [];\n          //attach data-X attr, and scope-X attr\n          for(x in attr) {\n            if (!x.indexOf('data-')) {\n              attrArray.push('\"' + x.slice(5) + '\":\"' + attr[x] + '\"');\n            } else if (!x.indexOf('scope-')) {\n              attrArray.push('\"' + x.slice(6) + '\":S[\"' + attr[x] + '\"]');\n            }\n          }\n          FnText += indent(level) + 'var P={' + attrArray.join(',') + '},U=\"' + attr['dota-render'] + '\";\\n';\n          //only expand if renderFn is ready in cache, but not in cache-dom (which unneeded)\n          FnText += indent(level) + 'doTA.C[U]&&!doTA.D[U]&&(R+=doTA.C[U](S,F,P,X)); \\n';\n        }\n\n        level++;\n      },\n\n      //void tag no need to write closing tag\n      voidTag: function() {\n        level--;\n\n        //close \"if\", \"for\", \"while\" blocks\n        while (LevelMap[level] > 0) {\n          FnText += indent(level, 1) + '}\\n';\n          LevelMap[level]--;\n        }\n\n        //clear ng-repeat $index\n        if (lastLevel === level) {\n          LevelVarMap[level] = 0;\n          lastLevel = void 0;\n        }\n\n        //reset dota-pass when out of scope\n        if (doTAPass && doTAPass >= level) {\n          doTAPass = 0;\n        }\n      },\n\n      //close tag\n      closeTag: function(tagName) {\n        level--;\n\n        //just write closing tag back\n        FnText += indent(level) + \"R+='</\" + tagName + \">';\\n\";\n\n        //ngIfCounter for most possible uniqueId generation; don't work with loop inside!\n        if (diffLevel && level === ngIfLevel && ngIfCounter >= 0) {\n          if (ngIfCounter) {\n            FnText += indent(level, 1) + '}else{N+=' + ngIfCounter + '; \\n';\n          }\n          ngIfLevel = ngIfCounter = void 0;\n        }\n\n        //close \"if\", \"for\", \"while\" blocks\n        while (LevelMap[level] > 0) {\n          FnText += indent(level, 1) + '}\\n';\n          LevelMap[level]--;\n        }\n\n        //clear ng-repeat $index\n        if (lastLevel === level) {\n          LevelVarMap[level] = 0;\n          lastLevel = void 0;\n        }\n\n        //add blank node if $watch block return nothing, mostly occur with ng-if\n        if (WatchMap[level]) {\n          FnText += indent(level, 1) +\n            \"R=R||('<\" + tagName + ' id=\"' + idHash[uniqueId + '.' + level] +\n            '\" style=\"display:none\"></' + tagName + '>\\');\\n';\n          WatchMap[level] = 0;\n          FnText += indent(level, 2) + 'return R;}; \\n';\n          FnText += indent(level, 2) + 'R+=W.F(S,F,$attr,X,N); \\n';\n        }\n\n        //reset dota-pass when out of scope\n        if (doTAPass && doTAPass >= level) {\n          doTAPass = 0;\n        }\n      },\n\n      //text node\n      text: function(text) {\n        //console.log([text]);\n        FnText += indent(level) + ('R+=\\'' + interpolate(text) + '\\';\\n')\n          .replace(/\\+''|''\\+/g,'');\n      },\n\n      //comment node\n      comment: function(data) {\n        //console.log(111,[data]);\n        FnText += indent(level) + \"R+='<\" + interpolate(data) + \">';\\n\";\n      }\n    });\n\n    if (isPatch) {\n      FnText += indent(0) + 'if(X&&J in doTA.H){doTA.diff' + (diffLevel || '') + '(J,R)}' +\n        'doTA.H[J]=R;\\n';\n    }\n\n    FnText += indent(0) +'return R;\\n';\n\n    //Default Optimization\n    // - concat possible lines for performance\n    FnText = FnText.replace(/;R\\+=/g,'+').replace(/'\\+'/g,'');\n\n    //extra optimization, which might take some more CPU\n    if (options.optimize && !isPatch) {\n      FnText = FnText.replace(removeUnneededQuotesRegex,'$1$2');\n    }\n\n    //print the whole function if debug\n    if (options.debug) {\n      /**/console.log(FnText);\n    }\n    // console.log(FnText);\n\n    try {\n      //$scope, $filter\n      compiledFn = new Function('S', 'F', '$attr', 'X', FnText);\n      if (Watched) {\n        compiledFn = {W:[], F: compiledFn};\n      }\n    } catch (err) {\n      if (typeof console !== \"undefined\") {\n        /**/console.log(\"doTA compile error:\\n\" + FnText);\n      }\n      throw err;\n    }\n\n    // just for less array usage on heap profiling\n    // but this may trigger GC more\n    FnText = level = lastLevel = LevelMap = LevelVarMap = VarMap = doTAPass = void 0;\n    return compiledFn;\n  }\n\n  var compiledHash = {};\n  var lastId = 0;\n\n  function initCompileHash(obj) {\n    for (var x in obj) {\n      compiledHash[x] = obj[x];\n      if (obj[x] > lastId) {\n        lastId = obj[x];\n      }\n    }\n  }\n\n  function getUniqueId(key) {\n    if (key) {\n      if (compiledHash[key]) {\n        return compiledHash[key];\n      } else {\n        compiledHash[key] = lastId;\n        return lastId++;\n      }\n    } else {\n      return lastId++;\n    }\n  }\n\n  var doTAObj = {\n    diff: diffPatchExact,\n    diff2: diffPatchChildren,\n    getId: getUniqueId,\n    initCH: initCompileHash,\n    compile: compileHTML,\n    C: {}, //Cached compiled functions\n    D: {}, //Cached DOM to be used by ngDoTA, needed here to prevent unneccessary rendering\n    H: {} //HashMap for TextDiff\n  };\n\n  //warmup most used functions\n  doTAObj.compile('<div class=\"x {{x}}\" ng-class=\"{x:1}\" ng-repeat=\"x in y\" ng-if=\"x\">x{{x}}</div><!--x-->', {\n    watchDiff: 1, diffLevel: 2});\n\n  return doTAObj;\n})();\n\nif (typeof module !== \"undefined\" && module.exports) {\n  module.exports = doTA;\n//IE8\n} else if (typeof console === \"undefined\") {\n  var noop = function() {};\n  console = {log: noop, time: noop, timeEnd: noop};\n}\n\n/* global angular, doTA */\n(function (angular, document) {'use strict';\n  var msie = document.documentMode;\n  var ie8 = msie <= 8;\n  var textContent = ie8 ? 'innerText' : 'textContent';\n  var hiddenDIV;\n  setTimeout(function(){\n    if (document.createElement) {\n      hiddenDIV = document.createElement('div');\n    }\n  },0);\n  var BoolMap = {0: 0, 'false': 0};\n  function makeBool(attr, defaultValue){\n    return attr in BoolMap ? BoolMap[attr] : attr || defaultValue;\n  }\n\n  function forEachArray(src, iter, ctx) {\n    if (src.forEach) {\n      return src.forEach(iter);\n    }\n    for (var key = 0, length = src.length; key < length; key++) {\n      if (key in src) {\n        iter.call(ctx, src[key], key);\n      }\n    }\n    return src;\n  }\n\n  //something like $eval to read value from nested objects with dots\n  function resolveObject(path, obj) {\n    return path.indexOf('.') >= 0 ? path.split('.').reduce(function (prev, curr) {\n      return prev ? prev[curr] : undefined;\n    }, obj) : obj[path];\n  }\n\n  //something like $parse\n  function parseObject(path, obj) {\n    if (path.indexOf('.') >= 0) {\n      var paths = path.split('.');\n      path = paths.splice(-1, 1)[0];\n      // console.log('path, last', paths, last)\n      obj = paths.reduce(function (prev, curr) {\n        // console.log('parseObject', [prev, curr])\n        if (!prev[curr]) {\n          prev[curr] = {};\n        }\n        return prev[curr];\n      }, obj);\n    }\n    return {\n      assign: function(val) {\n        obj[path] = val;\n      }\n    };\n  }\n\n  // var obj = {};\n  // var parsed = parseObject('name', obj);\n  // parsed.assign('test');\n  // console.log(obj);\n  // parsed = parseObject('three.one', obj);\n  // parsed.assign('haha');\n  // console.log(obj);\n\n  //debounce for events\n  // function debounce(fn, timeout) {\n  //   if (timeout === undefined) {\n  //     timeout = 200;\n  //   }\n  //   var timeoutId;\n  //   var args, thisArgs;\n  //   function debounced() {\n  //     fn.apply(thisArgs, args);\n  //   }\n  //   return function() {\n  //     args = arguments;\n  //     thisArgs = this;\n  //     if (timeoutId) {\n  //       clearTimeout(timeoutId);\n  //     }\n  //     // console.log('debounce: new timer', [timer]);\n  //     timeoutId = setTimeout(debounced, timeout);\n  //   };\n  // }\n\n  //throttle for events\n  function throttle(fn, timeout) {\n    if (timeout === undefined) {\n      timeout = 200;\n    }\n    var timeoutId;\n    var start = +new Date(), now;\n    // console.log('timeout', timeout)\n    var args, thisArgs;\n    function throttled() {\n      fn.apply(thisArgs, args);\n    }\n    return function() {\n      args = arguments;\n      thisArgs = this;\n      now = +new Date();\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n      if (now - start >= timeout) {\n        // console.log(now - start)\n        start = now;\n        throttled();\n        return;\n      }\n      // console.log('throttled: new timer', [timer]);\n      timeoutId = setTimeout(throttled, timeout);\n    };\n  }\n\n  //hide and destroy children\n  function destroyChildren(elem) {\n    var child = elem.firstChild, hiddenTags = [];\n    if (child) {\n      child.hidden = 1;\n      hiddenTags.push(child);\n      while (child = child.nextSibling) {\n        child.hidden = 1;\n        hiddenTags.push(child);\n      }\n    }\n    //destroying children block everything\n    // so do it later, since deleting don't have to be synchronous\n    setTimeout(function(){\n      console.time('removeChild');\n      forEachArray(hiddenTags, function(child) {\n        if (child && child.parentNode) {\n          child.parentNode.removeChild(child);\n        }\n      });\n      console.timeEnd('removeChild');\n    })\n  }\n\n  function addEvent(partial, scope, uniqueId) {\n    if (partial.de) { return; } //only attach events once\n    partial.de = 1;\n    var attrs = partial.attributes, attrName, attrVal;\n    var listenerName = ie8 ? 'attachEvent' : 'addEventListener';\n    // console.log('attrs', uniqueId, attrs);\n    for(var i = 0, l = attrs.length; i < l; i++) {\n      if (!attrs[i] || !attrs[i].name || !attrs[i].value) { continue; }\n      attrName = attrs[i].name;\n      attrVal = attrs[i].value;\n      if (attrName.substr(0, 3) === 'de-') {\n        //remove attribute, so never bind again\n        partial.removeAttribute(attrName);\n        partial[listenerName]((ie8 ? 'on' : '') + attrName.substr(3), (function(target, attrVal){\n          return function(evt){\n            if (ie8) {\n              //make $event.target always available\n              evt.target = evt.srcElement || document;\n              evt.returnValue = false;\n              evt.cancelBubble = true;\n            } else {\n              evt.preventDefault();\n              evt.stopPropagation();\n            }\n\n            //isedom: disallow, so no $target here\n            scope.$evalAsync(attrVal, {$event: evt});\n          };\n        })(partial, attrVal));\n        console.log('event added', uniqueId, attrName);\n      }\n    }\n  }\n\n  function addEvents(elem, scope, uniqueId) {\n    var elements = elem.querySelectorAll('[de]');\n    for (var i = 0, l = elements.length; i < l; i++) {\n      //remove attribute, so never bind again\n      elements[i].removeAttribute('de');\n      addEvent(elements[i], scope, uniqueId);\n    }\n  }\n\n  function addNgModels(elem, scope, uniqueId) {\n    forEachArray(elem.querySelectorAll('[ng-model]'), function(partial) {\n      var dotaPass = partial.getAttribute('dota-pass');\n      // console.log('dotaPass', [dotaPass]);\n      if (dotaPass != undefined) { return; } //null or undefined\n\n      //override ng-model\n      var modelName = partial.getAttribute('ng-model');\n\n      //remove attribute, so never bind again\n      partial.removeAttribute('ng-model');\n\n      //textbox default event is input unless IE8, all others are change event\n      var updateOn = partial.getAttribute('update-on') ||\n        (partial.type !== 'text' || ie8 ? 'change' : 'input');\n      var throttleVal = +partial.getAttribute('throttle') || 100;\n\n      //use checked property for checkbox and radio\n      var bindProp = partial.getAttribute('bind-prop') ||\n        ((partial.type === 'checkbox' || partial.type === 'radio') && 'checked');\n      var curValue = resolveObject(modelName, scope) || '';\n\n      // console.log('partial', [partial.tagName, partial.type])\n      if (bindProp) {\n        //set true or false on dom properties\n        partial[bindProp] = partial.value === curValue;\n      } else {\n        partial.value = curValue;\n      }\n\n      //bind each events\n      var parsed;\n      forEachArray(updateOn.split(' '), function(evtName){\n        evtName = evtName.trim();\n        partial.addEventListener(evtName, throttle(function(evt) {\n          if (!parsed) {\n            parsed = parseObject(modelName, scope);\n          }\n          evt.preventDefault();\n          evt.stopPropagation();\n\n          // console.log('event', evtName, evt.target, [evt.target[bindProp || 'value']])\n          scope.$applyAsync((function(){\n            if (bindProp) {\n              parsed.assign(bindProp && evt.target[bindProp] ? evt.target.value : undefined);\n            } else {\n              parsed.assign(evt.target.value);\n            }\n          }))\n        }, throttleVal));\n      });\n    });\n  }\n\n  angular.module('doTA', [])\n    .config(['$provide',function(P) {\n      P.factory('doTA', function(){\n        doTA.addEvents = addEvents;\n        doTA.addNgModels = addNgModels;\n        return doTA;\n      });\n    }])\n\n    .directive('dotaRender', ['doTA', '$http', '$filter', '$templateCache', '$compile', '$controller',\n      function(doTA, $http, $filter, $templateCache, $compile, $controller) {\n      return {\n        restrict: 'A',\n        priority: 10000,\n        terminal: true,\n        controller: angular.noop,\n        link: angular.noop,\n        compile: function() {\n          var Watchers = [], BindValues = {}; //New scope flag, new Scope\n\n          return function($scope, elem, attrs) {\n            //used attributes, good for minification with closure compiler;\n            var attrCacheDOM = attrs.cacheDom;\n            var attrDoTARender = attrs.dotaRender;\n            var attrScope = attrs.scope;\n            var attrNgController = attrs.ngController;\n            var attrLoose = attrs.loose;\n            var attrOptimize = attrs.optimize;\n            var attrEvent = attrs.event;\n            var attrDebug = attrs.debug;\n            var attrWatch = attrs.watch;\n            var attrEncode = attrs.encode;\n            var attrCompile = attrs.compile;\n            var attrModel = attrs.model;\n            var attrBind = attrs.bind;\n            var attrCompileAll = attrs.compileAll;\n            var attrDoTAOnload = attrs.dotaOnload;\n            var attrDoTAOnloadScope = attrs.dotaOnloadScope;\n            var attrLoaded = attrs.loaded;\n            var attrInline = attrs.inline;\n            var attrWatchDiff = attrs.watchDiff;\n            var origAttrMap = attrs.$attr;\n            var NewScope;\n\n            attrs.loose = makeBool(attrLoose, 1); //falsy => ''\n            attrs.optimize = makeBool(attrOptimize, 0);\n            attrDebug = attrs.debug = makeBool(attrDebug, 0);\n            attrEvent = attrs.event = makeBool(attrEvent, 1); //ng-click to native click\n            attrWatch = attrs.watch = typeof attrWatch === 'string' ? attrWatch : 0; //Firefox throw error if does not exists\n            var params = {};\n\n            if (attrCacheDOM && doTA.D[attrDoTARender]) {\n              // alert( doTA.D[attrDoTARender].innerHTML);\n              console.log('cacheDOM: just moved cached DOM', doTA.D[attrDoTARender]);\n              var cachedElem = msie ? doTA.D[attrDoTARender].cloneNode(true) : doTA.D[attrDoTARender];\n              elem[0].parentNode.replaceChild(cachedElem, elem[0]);\n              return;\n            }\n\n            //attributes on dota-render tags to be accessiable as $attr in templates\n            for (var x in origAttrMap) {\n              var z = origAttrMap[x];\n              //map data-* attributes into origAttrMap (inline text)\n              if (!z.indexOf('data-')) {\n                params[x] = attrs[x];\n              //map scope-* attributes into origAttrMap (first level var from scope)\n              } else if (!z.indexOf('scope-')) {\n                if (attrs[x].indexOf('.') >= 0 || attrs[x].indexOf('[') >= 0) {\n                  params[z.slice(6)] = $scope.$eval(attrs[x]);\n                } else {\n                  params[z.slice(6)] = $scope[attrs[x]];\n                }\n              }\n            }\n\n            //create new scope if scope=1 or ng-controller is specified\n            if (attrScope || attrNgController) {\n              console.log('scope', attrScope);\n              NewScope = $scope.$new();\n              console.log('newScope created', attrDoTARender, NewScope);\n            } else {\n              NewScope = $scope;\n            }\n\n            //attach ng-controller, and remove attr to prevent angular running again\n            if (attrNgController) {\n              var asPos = attrNgController.indexOf(' as ');\n              if (asPos > 0) {\n                attrNgController = attrNgController.substr(0, asPos).trim();\n              }\n              console.log('new controller', attrNgController);\n              var l = {$scope: NewScope}, controller = $controller(attrNgController, l);\n              if (attrs.controllerAs || asPos > 0) {\n                NewScope[attrs.controllerAs || attrNgController.substr(asPos + 4).trim()] = controller;\n              }\n              elem[0].removeAttribute('ng-controller');\n              elem.data('$ngControllerController', controller);\n              elem.children().data('$ngControllerController', controller);\n              console.log('new controller created', attrDoTARender);\n            }\n\n            // watch and re-render the whole template when change\n            if(attrWatch) {\n              console.log(attrDoTARender, 'registering watch for', attrWatch);\n              NewScope.$watchCollection(attrWatch, function(newVal, oldVal){\n                if(newVal !== oldVal && doTA.C[attrDoTARender]) {\n                  console.log(attrDoTARender, 'watch before render');\n                  render(doTA.C[attrDoTARender]);\n                  console.log(attrDoTARender, 'watch after render');\n                }\n              });\n            }\n\n            // watch and partially render by diffing. diff-level = 2 may be used to patch children\n            if(attrWatchDiff) {\n              console.log(attrDoTARender, 'registering diff watch for', attrWatchDiff);\n              NewScope.$watchCollection(attrWatchDiff, function(newVal, oldVal){\n                if(newVal !== oldVal && doTA.C[attrDoTARender]) {\n                  console.log(attrDoTARender, 'diff watch before render');\n                  render(doTA.C[attrDoTARender], true);\n                  console.log(attrDoTARender, 'diff watch after render');\n                }\n              });\n            }\n\n            // run the loader\n            loader();\n\n            ////////////////////////////////////////////////////////////////////////////\n            // cache-dom for static html, $scope will not be triggered\n            ////////////////////////////////////////////////////////////////////////////\n            function cacheDOM(){\n              // console.log('cacheDOM()', attrs)\n              $scope.$on(\"$destroy\", function(){\n                console.log('$destroy', elem);\n                // alert(['$destroy', elem[0], hiddenDIV]);\n                if (hiddenDIV) {\n                  doTA.D[attrDoTARender] = elem[0];\n                  hiddenDIV.appendChild(elem[0]);\n                }\n              });\n            }\n\n            ////////////////////////////////////////////////////////////////////////////\n            // doTA.compile and return compiledFn\n            ////////////////////////////////////////////////////////////////////////////\n            function compile(template) {\n              if(attrDebug) {\n                console.log(attrDoTARender + ':' + template);\n              }\n\n              console.log(attrDoTARender,'before compile');\n              //compile the template html text to function like doT does\n              try {\n                console.time('compile:' + attrDoTARender);\n                var compiledFn = doTA.compile(template, attrs);\n                console.timeEnd('compile:'  + attrDoTARender);\n                console.log(attrDoTARender,'after compile(no-cache)');\n              } catch (x) {\n                /**/console.log('compile error', attrs, template);\n                throw x;\n              }\n\n              //compiled func into cache for later use\n              if (attrDoTARender) {\n                doTA.C[attrDoTARender] = compiledFn;\n              }\n\n              return compiledFn;\n            }\n\n            ////////////////////////////////////////////////////////////////////////////\n            // attach ng-bind\n            ////////////////////////////////////////////////////////////////////////////\n            function addNgBind(rawElem, scope, attrDoTARender) {\n              //ToDo: check Watchers scope\n              while (Watchers.length) {\n                Watchers.pop()();\n              }\n              forEachArray(rawElem.querySelectorAll('[ng-bind]'), function(partial) {\n                //override ng-bind\n                var bindExpr = partial.getAttribute('ng-bind');\n                partial.removeAttribute('ng-bind');\n\n                if (BindValues[bindExpr]) {\n                  partial.innerHTML = BindValues[bindExpr];\n                }\n                Watchers.push(scope.$watchCollection(bindExpr, function(newVal, oldVal){\n                  if(newVal !== oldVal) {\n                    console.log(attrDoTARender, 'watch before bindExpr', newVal);\n                    partial[textContent] = BindValues[bindExpr] = newVal || '';\n                    console.log(attrDoTARender, 'watch after render');\n                  }\n                }));\n              });\n            }\n\n            ////////////////////////////////////////////////////////////////////////////\n            // attach ng-model, events, ng-bind, and $compile\n            ////////////////////////////////////////////////////////////////////////////\n            function attachEventsAndCompile(rawElem, scope) {\n\n              if (attrModel) {\n                addNgModels(rawElem, scope, attrDoTARender);\n              }\n\n              //attach events before replacing\n              if (attrEvent) {\n                addEvents(rawElem, scope, attrDoTARender);\n              }\n\n              //ng-bind\n              if (attrBind) {\n                addNgBind(rawElem, scope, attrDoTARender);\n              }\n\n              //$compile html if you need ng-model or ng-something\n              if (attrCompile){\n                //partially compile each dota-pass and its childs,\n                // not sure this is suitable if you have so many dota-passes\n                forEachArray(rawElem.querySelectorAll('[dota-pass]'), function(partial){\n                  $compile(partial)(scope);\n                });\n                console.log(attrDoTARender,'after $compile partial');\n\n              } else if (attrCompileAll){\n                //compile child nodes\n                $compile(rawElem.contentDocument || rawElem.childNodes)(scope);\n                console.log(attrDoTARender,'after $compile all');\n              }\n            }\n\n            ////////////////////////////////////////////////////////////////////////////\n            // render the template, cache-dom, run onload scripts, add dynamic watches\n            ////////////////////////////////////////////////////////////////////////////\n            function render(func, patch) {\n\n              //unless prerender\n              if (func) {\n                //trigger destroying children\n                if (!patch && elem[0].firstChild) {\n                  destroyChildren(elem[0]);\n                }\n\n                console.log(attrDoTARender, 'before render', patch);\n                //execute render function against scope, $filter, etc.\n                try {\n                  console.time('render:' + attrDoTARender);\n                  var v = func.F ? func.F(NewScope, $filter, params, patch) : func(NewScope, $filter, params, patch);\n                  console.timeEnd('render:' + attrDoTARender);\n                  console.log(attrDoTARender,'after render', patch);\n                } catch (x) {\n                  /**/console.log('render error', func);\n                  throw x;\n                }\n\n                if(attrDebug) {\n                  /* */console.log(attrDoTARender, v);\n                  // console.log(attrDoTARender, (func.F || func).toString());\n                }\n\n                // console.log('patch?', [patch]);\n                if (patch) {\n                  attachEventsAndCompile(elem[0], NewScope);\n                  return;\n                }\n\n                //if node has some child, use appendChild\n                if (elem[0].firstChild) {\n                  console.time('appendChild:' + attrDoTARender);\n                  var newNode = document.createElement('div'), firstChild;\n                  newNode.innerHTML = v;\n\n                  //if needed, attach events and $compile\n                  attachEventsAndCompile(newNode, NewScope);\n\n                  //move child from temp nodes\n                  while (firstChild = newNode.firstChild) {\n                    elem[0].appendChild(firstChild);\n                  }\n                  console.timeEnd('appendChild:' + attrDoTARender);\n                  console.log(attrDoTARender, 'after appendChild');\n\n                //if node is blank, use innerHTML\n                } else {\n                  console.time('innerHTML:' + attrDoTARender);\n                  elem[0].innerHTML = v;\n                  console.timeEnd('innerHTML:' + attrDoTARender);\n                  console.log(attrDoTARender, 'after innerHTML');\n\n                  //if needed, attach events and $compile\n                  attachEventsAndCompile(elem[0], NewScope);\n                }\n\n              //attach client side to prerender context\n              } else {\n                attachEventsAndCompile(elem[0], NewScope);\n              }\n\n              //execute raw functions, like jQuery\n              if(attrDoTAOnload){\n                setTimeout(function(){\n                  var onLoadFn = new Function(attrDoTAOnload);\n                  onLoadFn.apply(elem[0]);\n                  console.log(attrDoTARender,'after eval');\n                });\n              }\n\n              //execute scope functions\n              if(attrDoTAOnloadScope) {\n                setTimeout(function() {\n                  NewScope.$evalAsync(attrDoTAOnloadScope);\n                  console.log(attrDoTARender, 'after scope $evalAsync scheduled');\n                });\n              }\n\n              if (attrCacheDOM) {\n                cacheDOM();\n              }\n\n              //you can now hide raw html before rendering done\n              // with loaded=false attribute and following css\n              /*\n              [dota-render][loaded]:not([loaded=true]) {\n                display: none;\n              }\n              */\n              if (attrLoaded) {\n                elem.attr(\"loaded\",true);\n              }\n\n              //this watch may be dynamically add or remove\n              if (func && func.W) {\n                console.log('func.W watch', attrDoTARender, func.W);\n                var scopes = {}, watches = {};\n                for(var i = 0; i < func.W.length; i++) {\n                  var w = func.W[i];\n                  // console.log('watch', w);\n\n                  watches[w.I] = NewScope.$watchCollection(w.W, (function(w) {\n                    return function(newVal, oldVal){\n                      console.log('$watch trigger', [newVal, oldVal]);\n                      if (newVal === oldVal && !newVal) { return; }\n                      console.log(attrDoTARender, w.W, 'partial watch before render');\n                      var oldTag = document.getElementById(w.I);\n                      if (!oldTag) { return console.log('tag not found'); }\n\n                      //we don't need new scope here\n                      var content = w.F(NewScope, $filter, params, null, w.N);\n                      if (!content) { return console.log('no contents'); }\n                      console.log('watch new content', content);\n                      var newTag = angular.element(content);\n\n                      //compile only if specified\n                      if (w.C) {\n                        //scope management\n                        if (scopes[w.I]) {\n                          scopes[w.I].$destroy();\n                        }\n                        scopes[w.I] = NewScope.$new();\n                      }\n\n                      attachEventsAndCompile(newTag[0], scopes[w.I] || NewScope);\n\n                      angular.element(oldTag).replaceWith(newTag);\n\n                      console.log(attrDoTARender, w.W, 'partial watch content written');\n                      //unregister watch if wait once\n                      if (w.O) {\n                        console.log(attrDoTARender, w.W, 'partial watch unregistered');\n                        watches[w.I]();\n                      }\n                      console.log(attrDoTARender, w.W, 'partial watch after render');\n                    };\n                  })(w));\n                }\n              }\n            }\n\n            function loader(){\n              if(doTA.C[attrDoTARender]){\n                console.log(attrDoTARender,'get compile function from cache');\n                //watch need to redraw, also inline, because inline always hasChildNodes\n                if (elem[0].hasChildNodes() && !attrInline) {\n                  console.log('hasChildNodes', attrDoTARender);\n                  render();\n                } else {\n                  render(doTA.C[attrDoTARender]);\n                }\n              } else if (attrInline) {\n                // render inline by loading inner html tags,\n                // html entities encoding sometimes need for htmlparser here or you may use htmlparser2 (untested)\n                console.log(attrDoTARender,'before get innerHTML');\n                var v = elem[0].innerHTML;\n                console.log(attrDoTARender,'after get innerHTML');\n                render(compile(v, attrs));\n              } else if (attrDoTARender) { //load real template\n                console.log('before $http', attrDoTARender);\n                //server side rendering or miss to use inline attrs?\n                if (elem[0].hasChildNodes()) {\n                  console.log('hasChildNodes', attrDoTARender);\n                  render();\n                } else {\n                  $http.get(attrDoTARender, {cache: $templateCache}).success(function (v) {\n                    console.log('after $http response', attrDoTARender);\n                    render(compile(v, attrs));\n                  });\n                }\n              }\n            }\n\n            //////////////////////////////////////////////////\n\n          };\n        }\n      };\n    }])\n    .directive('dotaInclude', ['$http', '$templateCache', '$compile', function($http, $templateCache, $compile) {\n      return {\n        restrict: 'A',\n        priority: 10000,\n        terminal: true,\n        compile: function() {\n          return function(scope, elem, attrs) {\n            console.log('dotaInclude', attrs.dotaInclude);\n            $http.get(attrs.dotaInclude, {cache: $templateCache}).success(function (data) {\n              elem.html(data);\n              if (attrs.compile !== 'false') {\n                $compile(elem.contents())(scope);\n              }\n            });\n          };\n        }\n      };\n    }])\n    .directive('dotaTemplate', ['$http', '$templateCache', '$compile', function($http, $templateCache, $compile) {\n      return {\n        restrict: 'A',\n        priority: 10000,\n        terminal: true,\n        compile: function() {\n          return function(scope, elem, attrs) {\n            scope.$watch(attrs.dotaTemplate, function(newVal, oldVal) {\n              if (newVal) {\n                console.log('dotaTemplate', newVal);\n                $http.get(newVal, {cache: $templateCache}).success(function (data) {\n                  elem.html(data);\n                  if (attrs.compile !== 'false') {\n                    $compile(elem.contents())(scope);\n                  }\n                });\n              }\n            });\n          };\n        }\n      };\n    }])\n    .factory('dotaHttp', ['$compile', '$http', '$templateCache', '$filter', 'doTA',\n      function($compile, $http, $templateCache, $filter, doTA) {\n      return function (name, scope, callback, options){\n        options = options || {};\n        options.loose = 1;\n        // options.debug = 1;\n        // /**/console.log('options')\n\n        if (doTA.C[name]) {\n          // /**/console.log('dotaHttp doTA cache', name);\n          callback(doTA.C[name](scope, $filter));\n        } else {\n          // /**/console.log('dotaHttp $http', name);\n          $http.get(name, {cache: $templateCache}).success(function(data) {\n            // /**/console.log('dotaHttp response', data);\n            doTA.C[name] = doTA.compile(data, options);\n            callback(doTA.C[name](scope, $filter));\n          });\n        }\n      };\n    }]);\n\n})(window.angular, window.document);\n"],"sourceRoot":"/source/"}