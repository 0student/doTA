{"version":3,"sources":["ngDoTA.js"],"names":["doTA","F","k","d","c","forEach","b","a","length","call","M","indexOf","charAt","closeTag","substring","comment","g","f","h","n","t","q","e","slice","replace","toLowerCase","openTag","voidTag","text","G","console","error","document","getElementById","L","className","split","style","substr","trim","setAttribute","documentMode","String","prototype","this","Object","watch","unwatch","U","V","P","Z","S","X","Y","W","D","Q","I","T","diff","H","firstChild","nodeType","nodeValue","diff2","createElement","lastIndexOf","innerHTML","parentNode","replaceChild","insertBefore","createTextNode","appendChild","getId","initCH","compile","match","J","p","push","z","N","B","R","loose","watchDiff","diffLevel","$index","undefined","$attr","Math","Date","Array","Infinity","NaN","var","in","true","false","null","void","K","u","A","x","E","dotaRender","l","strip","encode",">","<","m","r","v","skip","y","w","O","C","refresh","elif","exec","model","bind","value","test","event","id","da","expand","join","optimize","debug","log","Function","module","exports","noop","time","timeEnd","reduce","splice","assign","apply","arguments","clearTimeout","setTimeout","hidden","nextSibling","removeChild","target","srcElement","returnValue","cancelBubble","preventDefault","stopPropagation","$evalAsync","$event","querySelectorAll","getElementsByClassName","de","attributes","name","events","ded","getAttribute","type","addEventListener","$applyAsync",1,"throttle","config","factory","addEvents","addNgModels","directive","restrict","priority","terminal","controller","link","$on","pop","$watchCollection","contentDocument","childNodes","aa","ea","attr","element","$destroy","$new","replaceWith","hasChildNodes","ba","get","cache","success","cacheDom","scope","ngController","compileAll","dotaOnload","dotaOnloadScope","loaded","inline","ca","removeAttribute","cloneNode","$eval","$scope","controllerAs","data","children","fa","dotaInclude","html","contents","$watch","dotaTemplate","window","angular"],"mappings":"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","file":"ngDoTA.min.js","sourcesContent":["var doTA = (function() {'use strict';\n  var msie = typeof document !== 'undefined' && document.documentMode;\n\n  /* for ie8 */\n  if (!String.prototype.trim) {\n    String.prototype.trim = function() {\n      return this.replace(/^\\s+|\\s+$/g,'');\n    };\n  }\n\n  /* no, thanks! firefox */\n  if (Object.prototype.watch) {\n    delete Object.prototype.watch;\n    delete Object.prototype.unwatch;\n  }\n\n  // pretty indent for debugging\n  function indent(n, x) {\n    var ret = new Array(n + 2).join('    ');\n    return x ? ret.slice(0, -2 * x) : ret;\n  }\n\n  function forEachArray(src, iter, ctx) {\n    if (!src) { return; }\n    if (src.forEach) {\n      return src.forEach(iter);\n    }\n    for (var key = 0, length = src.length; key < length; key++) {\n      iter.call(ctx, src[key], key);\n    }\n  }\n\n  // decode html entities\n  function decodeEntities(text) {\n    return text.indexOf('&') < 0 ? text : text\n      .replace(/&gt;/g, '>').replace(/&lt;/g, '<')\n      .replace(/&amp;/g, '&').replace(/&quot;/g, '\"');\n  }\n\n  // parse attributes from html open tag and make dict object\n  function parseAttr(chunk, func) {\n    var attr = {}, tagName;\n    var pos = chunk.indexOf(' ');\n    var spPos;\n    var len, attrName, attrVal;\n    var valStart, valEndPos;\n\n    if (pos !== -1) {\n      tagName = chunk.slice(0, pos);\n      len = chunk.length;\n\n      //console.log(222, [pos, chunk]);\n      while (++pos < len) {\n        var eqPos = chunk.indexOf('=', pos);\n\n        // ** attribute without value (last attribute) **\n        if (eqPos === -1) {\n          attrName = chunk.slice(pos);\n          // console.log('eqPos === -1', [attrName, pos, chunk])\n          if (attrName !== '/') {\n            attr[attrName] = '';\n          }\n          //attr required will be required=\"\", while is valid syntax\n          //http://www.w3.org/TR/html-markup/syntax.html#syntax-attr-empty\n          break;\n        }\n\n        // no val attr in middle\n        spPos = chunk.indexOf(' ', pos);\n        if (spPos > 0 && spPos < eqPos) {\n          attr[chunk.slice(pos, spPos)] = \"\";\n          pos = spPos;\n          continue;\n        }\n\n        //console.log(33, [eqPos]);\n        attrName = chunk.slice(pos, eqPos);\n        //console.log(331, [attrName]);\n\n        valStart = chunk[eqPos + 1];\n        //console.log(332, [valStart]);\n\n        //if attribute value is start with quote\n        if (valStart === '\"' || valStart === \"'\") {\n          valEndPos = chunk.indexOf(valStart, eqPos + 2);\n          if (valEndPos < 0) { throw 'ERR:Invalid HTML: [' + chunk + ']'; }\n\n          attrVal =  chunk.slice(eqPos + 2, valEndPos);\n          attr[attrName] =0>attrVal.indexOf(\"&\")?attrVal:attrVal.replace(/&gt;/g,\">\").replace(/&lt;/g,\"<\").replace(/&amp;/g,\"&\").replace(/&quot;/g,'\"'); //INLINE;\n          pos = valEndPos + 1;\n          //console.log(311, [valEndPos, attrName, attrVal]);\n        } else {\n\n          valEndPos = chunk.indexOf(' ', eqPos + 2);\n\n          //when no more attributes\n          if (valEndPos < 0) {\n            attrVal =  chunk.slice(eqPos + 1);\n            attr[attrName] =0>attrVal.indexOf(\"&\")?attrVal:attrVal.replace(/&gt;/g,\">\").replace(/&lt;/g,\"<\").replace(/&amp;/g,\"&\").replace(/&quot;/g,'\"'); //INLINE;\n            //console.log(442, [attrVal]);\n            break;\n\n          } else {\n            attrVal =  chunk.slice(eqPos + 1, valEndPos);\n            attr[attrName] =0>attrVal.indexOf(\"&\")?attrVal:attrVal.replace(/&gt;/g,\">\").replace(/&lt;/g,\"<\").replace(/&amp;/g,\"&\").replace(/&quot;/g,'\"'); //INLINE;\n            //console.log(313, [eqPos, valEndPos, attrVal]);\n            pos = valEndPos;\n          }\n        }\n      }\n\n      tagName = tagName.toLowerCase();\n      if (tagName === 'input' || tagName === 'img') {\n        //http://www.w3.org/TR/html-markup/syntax.html\n        //area, base, br, col, command, embed, hr, img, input, keygen, link, meta, param, source, track, wbr\n        func.openTag(tagName, attr, 1);\n        func.voidTag();\n      } else if (attrName === '/') {\n        func.openTag(tagName, attr);\n        func.closeTag(tagName);\n      } else {\n        func.openTag(tagName, attr);\n      }\n\n    // no attributes\n    } else {\n\n      // self closing, explicit\n      if (chunk.charAt(chunk.length - 1) === '/') {\n        tagName = chunk.slice(0, -1).toLowerCase();\n\n        if (tagName === 'br' || tagName === 'hr') {\n          func.openTag(tagName, attr, 1);\n          func.voidTag();\n        } else {\n          func.openTag(tagName, attr);\n          func.closeTag(tagName);\n        }\n      } else {\n        tagName = chunk.toLowerCase();\n\n        // self closing, implicit\n        if (tagName === 'br' || tagName === 'hr') {\n          func.openTag(tagName, attr, 1);\n          func.voidTag();\n        } else {\n          func.openTag(tagName, attr);\n        }\n      }\n    }\n\n  }\n\n  var events = ' scroll change click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste ';\n  var valid_chr = '_$abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n\n  // minimal stripped down html parser\n  function parseHTML(html, func) {\n    if (!html) { return; }\n    var prevPos = 0, pos = html.indexOf('<');\n    do {\n      if (html.charAt(pos) === '<') {\n        pos++;\n        if (html.charAt(pos) === '/') {\n          prevPos = ++pos;\n          pos = html.indexOf('>', prevPos);\n          //close tag must be like </div>, but not <div />\n          // console.log(['closetag', prevPos, pos, html.substring(prevPos, pos)])\n          func.closeTag(html.substring(prevPos, pos));\n        } else if (html.charAt(pos) === '!') {\n          prevPos = pos;\n          pos = html.indexOf('>', prevPos);\n          // console.log(['comment', prevPos, pos, html.substring(prevPos, pos)])\n          func.comment(html.substring(prevPos, pos));\n        } else {\n          prevPos = pos;\n          pos = html.indexOf('>', prevPos);\n          // console.log(['opentag', prevPos, pos, html.substring(prevPos, pos), parseAttr(html.substring(prevPos, pos))])\n          // func.openTag.apply(this, parseAttr(html.substring(prevPos, pos)));\n          parseAttr(html.substring(prevPos, pos), func);\n        }\n      } else if (html.charAt(pos) === '>') { //&& html.charAt(pos + 1) !== '<'\n        prevPos = ++pos;\n        pos = html.indexOf('<', prevPos);\n        if (pos > prevPos) {\n          // console.log(['text', prevPos, pos, html.substring(prevPos, pos)])\n          func.text(html.substring(prevPos, pos));\n        }\n      } else {\n        console.error('Parse ERR?', [prevPos, pos, html.substring(prevPos, pos), html.slice(pos)]);\n        break;\n      }\n\n    } while (pos > 0);\n  }\n\n  //diff and patch dom with exact same structure\n  function diffPatchExact(prevKey, html2) {\n    var html1 = doTA.H[prevKey];\n    var prevPos1 = 0, pos1 = html1.indexOf('<');\n    var prevPos2 = 0, pos2 = html2.indexOf('<');\n    var tagId = '', elem, part1, part2;\n    var posx, endPosx;\n\n    do {\n      if (html1.charAt(pos1) === \"<\") {\n        pos1++;\n        pos2++;\n        if (html1.charAt(pos1) === \"/\" || html1.charAt(pos1) === \"!\") {\n          //don't patch comment node and close tag.\n          pos1 = html1.indexOf('>', pos1);\n          pos2 = html2.indexOf('>', pos2);\n        } else {\n          prevPos1 = pos1;\n          prevPos2 = pos2;\n          pos1 = html1.indexOf('>', prevPos1);\n          pos2 = html2.indexOf('>', prevPos2);\n          part1 = html1.substring(prevPos1, pos1);\n          part2 = html2.substring(prevPos2, pos2);\n          //attributes\n          if (part1 !== part2) {\n            // console.log('openTag', [part1, part2])\n            tagId = parsePatchAttr(part1, part2);\n          } else {\n            //record id\n            //tagId = getTagId(part1);\n            posx = part1.indexOf(' id=\"');\n            0 <= posx && (posx += 5, endPosx = part1.indexOf('\"', posx), tagId = part1.substring(posx, endPosx));\n          }\n        }\n\n      //text node\n      } else if (html1.charAt(pos1) === '>') {\n        prevPos1 = ++pos1;\n        prevPos2 = ++pos2;\n\n        pos1 = html1.indexOf('<', prevPos1);\n        pos2 = html2.indexOf('<', prevPos2);\n        //textNode, only support firstChild here\n        if (pos2 > prevPos2) {\n          var text1 = html1.substring(prevPos1, pos1);\n          var text2 = html2.substring(prevPos2, pos2);\n          if (text1 !== text2) {\n            elem = document.getElementById(tagId);\n            if (elem) {\n              if (elem.firstChild && elem.firstChild.nodeType === 3) {\n                // console.log('textApplied', [text1, text2]);\n                elem.firstChild.nodeValue = text2;\n              } //else to log something?\n            } else {\n              console.log('tag not found', [tagId]);\n            }\n          }\n        }\n\n      }\n\n    } while(pos1 > 0);\n  }\n\n  // find position of outerHTML end\n  // this function will be inline during building\n  function getOuterHTMLEnd(HTML, START_POS) {\n    var LVL = 1, POS = START_POS;\n    for(;;) {\n      POS = HTML.indexOf('>', POS);\n      if (HTML.charAt(POS - 1) === '/') { //self closing\n        LVL--;\n        if (LVL <= 0) break;\n      }\n      POS = HTML.indexOf('<', POS);\n      if (HTML.charAt(POS + 1) === '/') {\n        LVL--;\n        if (LVL <= 0) {\n          POS = HTML.indexOf('>', POS + 2);\n          break;\n        }\n      } else if (HTML.charAt(POS + 1) !== '!') {\n        LVL++;\n      }\n      // console.log('LVL', LVL);\n    }\n\n    // console.log('getOutHTML', tagName, [tagName, pos2, pos2, ])\n    return ++POS;\n  }\n\n  // FlatDOM: diff html as text and patch dom nodes\n  function diffPatchChildren(prevKey, html2) {\n    var html1 = doTA.H[prevKey];\n    var prevPos1 = 0, pos1 = html1.indexOf('<');\n    var prevPos2 = 0, pos2 = html2.indexOf('<');\n    var tagId1, tagId2, elem1, part1, part2;\n    // var tagNo1 = 0, tagNo2 = 0;\n    var newNode = document.createElement('div');\n    var tagStartPos1, tagStartPos2;\n    var LVL; //this is needed for fnInline\n    // console.log(html1);\n    // console.log(html2);\n\n    for (;;) {\n      // console.log('before', [dirty1, dirty2], [tagId1, tagId2], [html1.substr(pos1, 20), html2.substr(pos2, 20)]);\n\n      if (pos1 >= 0) {\n        pos1 = html1.indexOf(' id=\"', pos1);\n        if (pos1 > 0) {\n          prevPos1 = pos1 + 5;\n          pos1 = html1.indexOf('\"', prevPos1);\n          tagId1 = html1.substring(prevPos1, pos1);\n          // tagNo1 = tagId1^0;\n        }\n      }\n\n      // console.log('middle', [tagId1, tagId2], [html1.substr(pos1, 20), html2.substr(pos2, 20)]);\n\n      if (pos2 >= 0) {\n        pos2 = html2.indexOf(' id=\"', pos2);\n        if (pos2 > 0) {\n          prevPos2 = pos2 + 5;\n          pos2 = html2.indexOf('\"', prevPos2);\n          tagId2 = html2.substring(prevPos2, pos2);\n          // tagNo2 = tagId2^0;\n        }\n      }\n\n      // console.log('after', [dirty1, dirty2], [tagId1, tagId2],\n      //   [pos1, pos2], [html1.substr(pos1, 20), html2.substr(pos2, 20)]);\n\n      //exist inifite loop\n      if (pos1 < 0 || pos2 < 0) break;\n\n      //same node\n      if (tagId1 === tagId2) {\n        tagStartPos1 = ++pos1;\n        pos1 = html1.indexOf('>', pos1);\n        part1 = html1.substring(tagStartPos1, pos1);\n\n        tagStartPos2 = ++pos2;\n        pos2 = html2.indexOf('>', pos2);\n        part2 = html2.substring(tagStartPos2, pos2);\n\n        // console.log('same node', [part1, part2]);\n\n        //attr really different\n        if (part1 !== part2) {\n          elem1 = document.getElementById(tagId1);\n          if (elem1) {\n            //nodes to be inserted or deleted\n            if ((part1.substr(1, 6) === 'hidden') !== (part2.substr(1, 6) === 'hidden')) {\n              tagStartPos2 = html2.lastIndexOf('<', pos2 - 6);\n              LVL=1,pos2=tagStartPos2;for(;;){pos2=html2.indexOf(\">\",pos2);if(\"/\"===html2.charAt(pos2-1)&&(LVL--,0>=LVL))break;pos2=html2.indexOf(\"<\",pos2);if(\"/\"===html2.charAt(pos2+1)){if(LVL--,0>=LVL){pos2=html2.indexOf(\">\",pos2+2);break}}else\"!\"!==html2.charAt(pos2+1)&&LVL++} //INLINE\n              newNode.innerHTML = html2.substring(tagStartPos2, pos2);\n\n              // tagStartPos1 = html1.lastIndexOf('<', pos1 - 6);\n              // console.warn('replaceChild', [tagId2, tagId1], [\n              //   html2.substring(tagStartPos2, getOuterHTMLEnd(html2, tagStartPos2)),\n              //   html1.substring(tagStartPos1, getOuterHTMLEnd(html1, pos1))]);\n\n              elem1.parentNode.replaceChild(newNode.firstChild, elem1);\n\n              LVL=1,pos1=pos1;for(;;){pos1=html1.indexOf(\">\",pos1);if(\"/\"===html1.charAt(pos1-1)&&(LVL--,0>=LVL))break;pos1=html1.indexOf(\"<\",pos1);if(\"/\"===html1.charAt(pos1+1)){if(LVL--,0>=LVL){pos1=html1.indexOf(\">\",pos1+2);break}}else\"!\"!==html1.charAt(pos1+1)&&LVL++} //INLINE\n\n            //only attribute changes\n            } else {\n              parsePatchAttr(part1, part2, elem1);\n              // console.warn('patch node', [tagId1, tagId2], [pos1, pos2], [tagStartPos1, tagStartPos2], [part1, part2])\n            }\n          } else {\n            console.error('elem not found', [tagId1, tagId2], [part1, part2]);\n            return;\n          }\n        } else {\n          //clear node for textNode\n          elem1 = void 0;\n        }\n\n        //if blank text node, skip early\n        if (html1.charAt(pos1 + 1) === '<' && html2.charAt(pos2 + 1) === '<') {\n          pos1++, pos2++;\n          continue;\n        }\n\n        prevPos1 = pos1;\n        pos1 = html1.indexOf('<', prevPos1);\n        part1 = html1.substring(prevPos1 + 1, pos1);\n        prevPos2 = pos2;\n        pos2 = html2.indexOf('<', prevPos2);\n        part2 = html2.substring(prevPos2 + 1, pos2);\n\n        //for text node really diff\n        if (part1 !== part2) {\n          // console.log('text diff', [tagId1, tagId2], [part1, part2]);\n          if (!elem1) {\n            elem1 = document.getElementById(tagId1);\n            if (!elem1) {\n              console.error('node not found', [tagId1, tagId2], [part1, part2], [html1.substr(pos1, 15), html2.substr(pos2, 15)], [html1, html2]);\n              return;\n            }\n          }\n          // console.log('part1,2', [part1, part2]);\n          if (elem1.firstChild) {\n            //overwrite textNode value\n            if (elem1.firstChild.nodeType === 3) {\n              elem1.firstChild.nodeValue = part2;\n              // console.warn('textNode overwritten', elem1, elem1.firstChild)\n\n            //not textNode, so, insertBefore\n            } else {\n              elem1.insertBefore(document.createTextNode(part2), elem1.firstChild);\n              // console.warn('textNode inserted', elem1, elem1.firstChild)\n            }\n\n          //no childNodes, so append one\n          } else {\n            elem1.appendChild(document.createTextNode(part2));\n          }\n        }\n      } else {\n        console.error(\"different Id - not supported for now!\", [tagId1, tagId2]);\n        return;\n      }\n\n    } //infinite loop\n\n  }\n\n  // parse attributes from html open tag and patch DOM when different\n  function parsePatchAttr(chunkA, chunkB, elem) {\n    var tagId;\n    var posA1, posA2, posB1, posB2;\n    var posDiff = 0;\n    var attrName, attrVal1, attrVal2;\n    // var len1 = chunk1.length;\n    // console.log('chunks', [chunkA, chunkB]);\n\n    //extract id to tag, if no elem specified\n    if (!elem) {\n      posA1 = chunkA.indexOf(' id=\"', posA1);\n      if (posA1 >= 0) {\n        posA1 += 5;\n        posA2 = chunkA.indexOf('\"', posA1);\n        tagId = chunkA.slice(posA1, posA2);\n        elem = document.getElementById(tagId);\n        if (!elem) {\n          throw console.error('tag not found', [posA1, posA2, tagId, elem, chunkA, chunkB]);\n        }\n        posA2 += 2;\n      } else {\n        throw console.error('id not found', [posA1, posA1, chunkA, chunkB]);\n      }\n    } else {\n      //first char is always space\n      posA2 = posB2 = 1;\n    }\n\n    for(;;) {\n      //attr name\n      posA1 = chunkA.indexOf('=\"', posA2);\n      if (posA1 < 0) break;\n      attrName = chunkA.slice(posA2, posA1);\n\n      //attr values\n      posA2 = chunkA.indexOf('\"', posA1 + 2);\n      attrVal1 =  chunkA.slice(posA1 + 2, posA2);\n\n      posB1 = posA1 + posDiff;\n      posB2 = chunkB.indexOf('\"', posB1 + 2);\n      attrVal2 =  chunkB.slice(posB1 + 2, posB2);\n\n      if (attrVal1 !== attrVal2) {\n        // console.log('setAttribute', [attrName, attrVal1, attrVal2], [chunk1, chunk2])\n        if (attrName === 'value') {\n          elem[attrName] = attrVal2;\n        } else {\n          if (msie) {\n            if (attrName === 'class') {\n              elem.className = attrVal2;\n            } else if (attrName === 'style') {\n              forEachArray(attrVal2.split(';'), function(item){\n                var colonPos = item.indexOf(':');\n                // console.log('style', [item.substr(0, colonPos).trim(), item.slice(colonPos+1).trim()])\n                elem.style[item.substr(0, colonPos).trim()] = item.slice(colonPos+1).trim();\n              })\n            } else {\n              elem.setAttribute(attrName, attrVal2);\n            }\n          } else {\n            elem.setAttribute(attrName, attrVal2);\n          }\n        }\n        posDiff = posB2 - posA2;\n      }\n\n      posA2 += 2;\n    }\n\n    return tagId;\n  }\n\n  // extract value of id from part of html open tag\n  // only id=\"xxx\" supported, this is internal use, so it's always double-quotes\n  // this function is inlined during building\n  function getTagId(partial, start) {\n    var pos = partial.indexOf(' id=\"', start), endPos;\n    if (pos >= 0) {\n      pos += 5;\n      endPos = partial.indexOf('\"', pos);\n      return partial.substring(pos, endPos);\n    }\n  }\n\n  // split filters into array, take care of | and || as different\n  function splitFilters(input, pos) {\n    var prevPos = 0;\n    var ret = [];\n    while (pos !== -1) {\n      if (input.charAt(pos + 1) === '|') {\n        pos += 2;\n      } else {\n        ret.push(input.substring(prevPos, pos));\n        prevPos = ++pos;\n      }\n      pos = input.indexOf('|', pos);\n    }\n    if (prevPos < input.length) {\n      ret.push(input.substr(prevPos));\n    }\n    return ret;\n  }\n\n  // ToDo: check compile performance with regex\n  var ngClassRegex = /('[^']+'|\"[^\"]+\"|[\\w$]+)\\s*:\\s*((?:[$.\\w]+|\\([^)]+\\)|[^},])+)/g;\n  var varOrStringRegex = /'[^']*'|\"[^\"]*\"|[\\w$]+|[^\\w$'\"]+/g;\n  var quotedStringRegex = /\"[^\"]*\"|'[^']*'/g;\n  var whiteSpaceRegex = /\\s{2,}|\\n/g;\n  var removeUnneededQuotesRegex = /\\b([\\w_-]+=)\"([^\"'\\s]+)\"(?=[\\s>])/g;\n  var lazyNgAttrRegex = /^(?:src|alt|title|href)/;\n  // https://github.com/kangax/html-minifier/issues/63\n  var noValAttrRegex = /^(?:checked|selected|disabled|readonly|multiple|required|hidden|nowrap)/;\n  var $indexRegex = /\\$index/g;\n  var $parent$indexRegex = /(?:\\$parent\\.)+\\$index/g;\n\n  // exported as doTA.compile\n  function compileHTML(template, options) {\n    options = options || {};\n    var val_mod = options.loose ? \"||''\" : '';\n    var watchDiff = options.watchDiff;\n    var diffLevel = +options.diffLevel;\n    var VarMap = {$index: 1, undefined: 1, $attr: 1,\n      Math: 1, Date: 1, String: 1, Object: 1, Array: 1, Infinity: 1, NaN: 1,\n      // alert: 1, confirm: 1, prompt: 1,\n      var: 1, in: 1,\n      true: 1, false: 1, null: 1, void: 1};\n    var level = 0, ngRepeatLevel;\n    var ngIfLevel, skipLevel, ngIfCounterTmp, ngIfLevels = [], ngIfLevelMap = {};\n    var LevelMap = {}, LevelVarMap = {};\n    var WatchMap = {}, Watched;\n    var doTAPass, doTAContinue;\n    var compiledFn;\n    var uniqueId = this.getId(options.dotaRender);\n    var idHash = {};\n\n    var FnText = indent(level) + \"'use strict';var \" +\n      (watchDiff ? 'N=1,J=' + uniqueId + ',' : '') +\n      \"R='';\\n\"; //ToDO: check performance on var declaration\n\n    //clean up extra white spaces and line break\n    template = template.replace(whiteSpaceRegex, ' ');\n\n    if (options.strip) {\n      template = template.replace(/>\\s+/g, '>').replace(/\\s+</g, '<');\n    }\n\n    // when encode is set, find strings and encode < and >, or parser will throw error.\n    if (options.encode) {\n      template = template.replace(quotedStringRegex, function($0) {\n        return $0.replace(/[<>]/g, function($00) {\n          return {'>': '&gt;', '<': '&lt;'}[$00];\n        });\n      });\n    }\n\n    // attach plain variables to scope variables\n    function attachScope(v) {\n      //console.log(VarMap, [v]);\n      if (v) {\n        //var DEBUG = /error/.test(v);\n        //DEBUG && console.log(11, [v]);\n\n        //ToDo: still buggy, this need to improve\n        var vv = '';\n        var matches = v.match(varOrStringRegex);\n        //DEBUG && console.log(12, matches);\n        for(var i = 0; i < matches.length; i++) {\n\n          if (valid_chr.indexOf(matches[i].charAt(0)) >= 0 && !VarMap[matches[i]] &&\n            (!i || matches[i-1][matches[i-1].length-1] !== '.')) {\n            vv += 'S.' + matches[i];\n          } else {\n            if (matches[i].indexOf('$index') >= 0) {\n              //only support last level for now\n              vv += matches[i].replace($indexRegex, LevelVarMap[ngRepeatLevel]);\n            } else {\n              vv += matches[i];\n            }\n          }\n        }\n        //DEBUG && console.log(55, vv);\n        return vv;\n      }\n      return v;\n    }\n\n    // escape single quotes with backslash\n    function escapeSingleQuote(str) {\n      var quotePos = str.indexOf(\"'\");\n      if (quotePos >= 0) {\n        var ret = '';\n        var prevQuotePos = 0;\n        do {\n          ret += str.substring(prevQuotePos, quotePos);\n          //escaped quote\n          if (str.charAt(quotePos - 1) !== '\\\\') {\n            ret += \"\\\\\";\n          }\n          prevQuotePos = quotePos;\n          quotePos = str.indexOf(\"'\", prevQuotePos + 1);\n        } while (quotePos > 0);\n        ret += str.substr(prevQuotePos);\n        return ret;\n      } else {\n        return str;\n      }\n    }\n\n    // interpolation\n    function interpolate(str) {\n      var pos = str.indexOf('{{');\n      if (pos >= 0) {\n        var prevPos = 0;\n        var ret = '';\n        var outsideStr, insideStr;\n        do {\n          outsideStr = str.substring(prevPos, pos);\n          ret += escapeSingleQuote(outsideStr);\n\n          //skip {{\n          prevPos = pos + 2;\n          pos = str.indexOf('}}', prevPos);\n\n          insideStr = str.substring(prevPos, pos);\n          ret += \"'+(\" + attachFilter(insideStr) + val_mod + \")+'\";\n\n          //skip }} for next\n          prevPos = pos + 2;\n          pos = str.indexOf('{{', prevPos);\n        } while (pos > 0);\n\n        //remaining text outside interpolation\n        ret += escapeSingleQuote(str.substr(prevPos));\n        return ret;\n      } else {\n        return escapeSingleQuote(str);\n      }\n    }\n\n    // attach $filters\n    function attachFilter($1) {\n      //console.log(333,$1);\n      var pos = $1.indexOf('|');\n      if (pos === -1) {\n        return attachScope($1);\n      } else {\n        //ToDo: check this line later\n        var v = splitFilters($1, pos);\n        var val = attachScope(v[0]);\n        var prevColonPos, colonPos;\n        var filter;\n\n        //parse each filters\n        for(var i = 1; i < v.length; i++) {\n          filter = v[i], prevColonPos = 0;\n\n          colonPos = filter.indexOf(':');\n          //filter with params\n          if (colonPos > 0) {\n            val = \"F('\" + filter.slice(prevColonPos, colonPos).trim() + \"')(\" + val;\n            prevColonPos = ++colonPos;\n            colonPos = filter.indexOf(':', prevColonPos);\n            while (colonPos > 0) {\n              val += ',' + attachScope(filter.slice(prevColonPos, colonPos));\n              prevColonPos = ++colonPos;\n              colonPos = filter.indexOf(':', prevColonPos);\n            }\n            val += ',' + attachScope(filter.substr(prevColonPos)) + ')';\n\n          //filter without params\n          } else {\n            val = \"F('\" + filter.trim() + \"')(\" + val + ')';\n          }\n\n        }\n        return val;\n      }\n    }\n\n    function apply$index(attrVal) {\n      var count, tmpRepeatLevel;\n\n      if (attrVal.indexOf('$parent.$index') >= 0) {\n        tmpRepeatLevel = ngRepeatLevel;\n        attrVal = attrVal.replace($parent$indexRegex, function($0) {\n          count = $0.match(/\\$parent/g).length; //may need to rewrite with indexOf\n          while (count>0) {\n            while (tmpRepeatLevel >= 0 && typeof LevelVarMap[--tmpRepeatLevel] === 'undefined') {}\n            --count;\n          }\n          return \"'+\" + LevelVarMap[tmpRepeatLevel] + \"+'\";\n        });\n      }\n      if (attrVal.indexOf('$index') >= 0) {\n        return attrVal.replace($indexRegex, \"'+\" + LevelVarMap[ngRepeatLevel] + \"+'\");\n      }\n      return attrVal;\n    }\n\n    //parse the element\n    parseHTML(template, {\n      //open tag with attributes\n      openTag: function(tagName, attr, selfClosing) {\n        // debug && console.log('openTag', [tagName, attr]);\n        var parsedAttr = {}, customId, tagId, noValAttr = '';\n        var attrName, attrVal, attrSkip, oneTimeBinding, doTAPassThis;\n\n        //skip parsing if dota-pass is specified (interpolation will still be expanded)\n        // https://jsperf.com/hasownproperty-vs-in-vs-undefined/12\n        if (typeof attr['dota-pass'] !== 'undefined') {\n          if (attr['dota-pass'] === 'this') {\n            doTAPass = doTAPassThis = 1;\n          } else {\n            doTAPass = level; doTAContinue = 0;\n          }\n        //re-enable dota parsing\n        } else if (typeof attr['dota-continue'] !== 'undefined') {\n          doTAContinue = level;\n        }\n\n        //unless dota-pass or with dota-continue\n        if (doTAPass === void 0 || doTAContinue) {\n          if (diffLevel && attr.skip) {\n            skipLevel = level;\n            attrSkip = attr.skip;\n            attr.skip = void 0;\n            FnText += indent(level, 1) + 'var O'+ level + '=N+' + attrSkip + '; \\n';\n          }\n\n          //ng-repeat to while/for loop\n          if (attr['ng-repeat']) {\n            //console.log(21,[x], [val]);\n            LevelMap[level] = LevelMap[level] ? LevelMap[level] + 1 : 1;\n            var idx = 'i' + level, l = 'l'+ level;\n            var NG_REPEAT = attr['ng-repeat'];\n            var inPos = NG_REPEAT.indexOf(' in ');\n            var repeatVar = NG_REPEAT.substr(0, inPos), repeatSrc = NG_REPEAT.substr(inPos + 4);\n            var commaPos = repeatVar.indexOf(',');\n            var pipePos = repeatSrc.indexOf('|'), repeatSrcNew;\n            var colonPos, x;\n\n            //store variable name to use for $index later\n            //this is ng-repeat specific, LevelMap[level] is same for ng-if too\n            LevelVarMap[level] = idx;\n            ngRepeatLevel = level;\n\n            if (pipePos > 0) {\n              repeatSrcNew = attachFilter(repeatSrc);\n            } else {\n              colonPos = repeatSrc.indexOf(':');\n              // if (colonPos < 0) {\n                repeatSrcNew = attachScope(repeatSrc);\n              // }\n            }\n\n            // Range: \"i in 1:10\" ==> (for i = 1; i < 10; i++)\n            if (colonPos >= 0) {\n              var start = repeatSrcNew.substr(0, colonPos) || 0, end, step;\n              var anotherColon = repeatSrcNew.indexOf(':', ++colonPos);\n              if (anotherColon > 0) {\n                end = repeatSrcNew.substring(colonPos, anotherColon);\n                step = repeatSrcNew.substr(anotherColon + 1);\n              } else {\n                end = repeatSrcNew.substr(colonPos);\n                step = 1;\n              }\n              // console.log([start, end, step])\n\n              FnText += indent(level, 1) + 'for(var ' +\n                repeatVar + '=' + start + ';' +\n                repeatVar + (step > 0 ? '<' : '>') + end + ';' + repeatVar + '+=' + step + '){\\n';\n              VarMap[repeatVar] = 1;\n\n            // Object: \"k, v in {}\" ==> (for in {})\n            } else if (commaPos > 0) {\n              var key = repeatVar.substr(0, commaPos);\n              var value = repeatVar.substr(commaPos + 1);\n              FnText += indent(level, 1) + 'var ' +\n                value + ',D' + level + '=' + repeatSrcNew + ';\\n';\n              FnText += indent(level, 1) + 'for(var ' + key + ' in D' + level + '){\\n';\n              //                             space is needed for manual uglify  ->  vvv\n              FnText += indent(level) + value + ' = ' + 'D' + level + '[' + key + ']; \\n';\n              VarMap[key] = VarMap[value] = 1;\n\n            // Array: \"k in []\" ==> while loop\n            } else {\n              FnText += indent(level, 1) + 'var ' +\n                repeatVar + ',D' + level + '=' + repeatSrcNew + ','\n                + idx + '=-1,' + l + '=D' + level + '.length;\\n';\n              FnText += indent(level, 1) + 'while(++' + idx + '<' + l + '){\\n';\n              //                        space is needed for manual uglify  ->  vvv\n              FnText += indent(level) + repeatVar + '=D' + level + '[' + idx + ']; \\n';\n              VarMap[repeatVar] = 1;\n            }\n            //remote attribute not to get forwarded to angular\n            attr['ng-repeat'] = void 0;\n          }\n\n          //re-render sub template\n          if (attr.refresh) {\n            customId = 1;\n            oneTimeBinding = attr.refresh.indexOf('::');\n            FnText += indent(level, 2) +\n              (!Watched ? 'var ' + (watchDiff ? '': 'N=1,') + 'T=this;T.W=[];' : '') +\n              'var W={N:N,I:N+\"' + '.' + uniqueId + '\",W:\"' +\n              (oneTimeBinding >=0 ? attr.refresh.substr(oneTimeBinding + 2) + '\",O:1': attr.refresh + '\"') +\n              (attr.compile ? ',C:1' : '') +\n              '};T.W.push(W);\\n';\n            WatchMap[level] = Watched = 1;\n            FnText += indent(level, 2) + 'W.F=function(S,F,$attr,X,N){var R=\"\";\\n';\n            attr.refresh = void 0;\n          }\n\n          if (attr['ng-init']) {\n            FnText += indent(level) + attachScope(attr[\"ng-init\"]) + '; \\n';\n            attr['ng-init'] = void 0;\n          }\n\n          //ng-if to javascript if\n          if (attr['ng-if']) {\n            if (diffLevel) {\n              ngIfLevel = level;\n              ngIfLevels.push(level);\n              ngIfLevelMap[level] = 0;\n            }\n            LevelMap[level] = LevelMap[level] ? LevelMap[level] + 1 : 1;\n            FnText += indent(level, 1) + 'if('+ attachScope(attr['ng-if']) +'){\\n';\n            // console.log('ng-if starts here', level);\n            attr['ng-if'] = void 0;\n          }\n\n          if (attr['elif']) {\n            FnText += indent(level, 1) + 'else if('+ attachScope(attr['elif']) +'){\\n';\n            LevelMap[level] = LevelMap[level] ? LevelMap[level] + 1 : 1;\n            attr['elif'] = void 0;\n          }\n\n          if (typeof attr['else'] !== 'undefined' && !watchDiff) {\n            FnText += indent(level, 1) + 'else{\\n';\n            LevelMap[level] = LevelMap[level] ? LevelMap[level] + 1 : 1;\n            attr['else'] = void 0;\n          }\n\n          //remove +''+ from class, for unnecessary string concat\n          if (attr.class) {\n            parsedAttr.class = interpolate(attr.class);\n            attr.class = void 0;\n          }\n\n          if (attr['ng-class']) {\n            var match;\n            var ngScopedClass = attachScope(attr['ng-class']);\n            parsedAttr.class = parsedAttr.class || '';\n            while((match = ngClassRegex.exec(ngScopedClass)) !== null) {\n              parsedAttr.class +=\n                (\"'+(\" + match[2] + '?' +\n                  \"'\" + (parsedAttr.class ? ' ' : '') + match[1].replace(/['\"]/g, '') +\n                  \"':'')+'\");\n            }\n            attr['ng-class'] = void 0;\n          }\n\n          if (attr['ng-show']) {\n            parsedAttr.class = parsedAttr.class || '';\n            parsedAttr.class += \"'+(\" + attachScope(attr['ng-show']) +\n              \"?'':'\" + (parsedAttr.class ? ' ' : '') + \"ng-hide')+'\";\n            attr['ng-show'] = void 0;\n          }\n\n          if (attr['ng-hide']) {\n            parsedAttr.class = parsedAttr.class || '';\n            parsedAttr.class += \"'+(\" + attachScope(attr['ng-hide']) +\n              \"?'\" + (parsedAttr.class ? ' ' : '') + \"ng-hide':'')+'\";\n            attr['ng-hide'] = void 0;\n          }\n\n          if (options.model && attr['ng-model']) {\n            if (attr['ng-model'].indexOf('$index') >= 0) {\n              parsedAttr['dota-model'] = apply$index(attr['ng-model']);\n            } else {\n              parsedAttr['dota-model'] = attr['ng-model'];\n            }\n            attr['ng-model'] = void 0;\n          }\n\n          if (options.bind && attr['ng-bind']) {\n            if (attr['ng-bind'].indexOf('$index') >= 0) {\n              parsedAttr['dota-bind'] = apply$index(attr['ng-bind']);\n            } else {\n              parsedAttr['dota-bind'] = attr['ng-bind'];\n            }\n            attr['ng-bind'] = void 0;\n          }\n\n          if (attr['ng-value']) {\n            parsedAttr.value = \"'+(\" + attachScope(attr['ng-value']) + \")+'\";\n            attr['ng-value'] = void 0;\n          }\n\n          //some cleanup\n          if (parsedAttr.class) {\n            parsedAttr.class = parsedAttr.class.replace(/\\+''\\+/g, '+');\n          }\n\n          // expand interpolations on attributes, and some more\n          for (x in attr) {\n            attrVal = attr[x];\n            if (attrVal === void 0) { continue; }\n\n            // some ng- attributes\n            if (x.substr(0, 3) === 'ng-') {\n              //some ng-attr are just don't need it here.\n              attrName = x.substr(3);\n              //something like ng-src, ng-href, etc.\n              if (lazyNgAttrRegex.test(attrName)) {\n                x = attrName;\n\n              //convert ng-events to dota-events, to be bind later with native events\n              } else if (options.event && events.indexOf(' ' + attrName + ' ') >= 0) {\n                //add class 'de' for one time querying\n                parsedAttr.class = parsedAttr.class ? 'de ' + parsedAttr.class : 'de';\n                // parsedAttr.de = 1;\n                x = 'de-' + attrName;\n\n              } else if (noValAttrRegex.test(attrName)) {\n                noValAttr += \"'+(\" + attachScope(attrVal) + \"?' \" + attrName + \"=\\\"\\\"':'')+'\";\n                //noValAttr will attach later\n                continue;\n\n              }\n            }\n\n            //ng-repeat loop variables are not available!\n            // only way to acccess is to use $index like \"data[$index]\"\n            // instead of \"item\" as in \"item in data\"\n            parsedAttr[x] = apply$index(interpolate(attrVal));\n          }\n\n        // pass all attributes to angular, except interpolation and $index\n        } else {\n          if (doTAPassThis) {\n            doTAPass = void 0;\n          }\n          //still expand interpolation even if dota-pass is set\n          for (x in attr) {\n            parsedAttr[x] = apply$index(interpolate(attr[x]));;\n          }\n        }\n\n        //write tag back as string\n        FnText += indent(level) + \"R+='<\" + tagName;\n\n        //make id attr come before anything\n        if (customId || watchDiff) {\n          tagId = idHash[uniqueId + '.' + level] = parsedAttr.id || (\"'+N+++'.\" + uniqueId);\n          FnText += ' id=\"' + tagId + '\"';\n          if (parsedAttr.id) {\n            parsedAttr.id = void 0;\n          }\n        }\n\n        //write back attributes\n        for(var k in parsedAttr) {\n          FnText += \" \" + k + '=\"' + parsedAttr[k] + '\"';\n        }\n\n        //attach boolean attributes at last\n        FnText += noValAttr +  (selfClosing ? ' /' : '') + \">';\\n\";\n\n        if (watchDiff) {\n          // FnText += indent(level) + \"N++; \\n\";\n          if (ngIfLevelMap[ngIfLevel] >= 0) {\n            ngIfLevelMap[ngIfLevel]++;\n            // console.log('isPath ngIfCounter', [tagName, ngIfCounter]);\n          }\n        }\n\n        //expand doTA templates with expand=1 option\n        if (attr['dota-render'] && attr.expand) {\n          var attrArray = [];\n          //attach data-X attr, and scope-X attr\n          for(x in attr) {\n            if (!x.indexOf('data-')) {\n              attrArray.push('\"' + x.slice(5) + '\":\"' + attr[x] + '\"');\n            } else if (!x.indexOf('scope-')) {\n              attrArray.push('\"' + x.slice(6) + '\":S[\"' + attr[x] + '\"]');\n            }\n          }\n          FnText += indent(level) + 'var P={' + attrArray.join(',') + '},U=\"' + attr['dota-render'] + '\";\\n';\n          //only expand if renderFn is ready in cache, but not in cache-dom (which unneeded)\n          FnText += indent(level) + 'doTA.C[U]&&!doTA.D[U]&&(R+=doTA.C[U](S,F,P,X)); \\n';\n        }\n\n        level++;\n      },\n\n      //void tag no need to write closing tag\n      voidTag: function() {\n        level--;\n\n        if (diffLevel && level === ngIfLevel && ngIfLevelMap[ngIfLevel] >= 0) {\n          // console.log('ngIfLevelMap1', ngIfLevel, ngIfLevels, ngIfLevelMap);\n          if (ngIfLevelMap[ngIfLevel]) {\n            FnText += indent(level, 1) + \"}else{\" +\n              \"R+='<span id=\\\"'+N+'.\" + uniqueId + '\" hidden=\"\"></span>\\';' +\n              \"N+=\" + ngIfLevelMap[ngIfLevel] + \";}; \\n\";\n          }\n          //save counter\n          ngIfCounterTmp = ngIfLevelMap[ngIfLevel];\n          //clear counter\n          ngIfLevelMap[ngIfLevel] = void 0;\n          //remove last level\n          ngIfLevel = ngIfLevels[--ngIfLevels.length - 1];\n          //add up to previous level\n          if (ngIfLevel) {\n            ngIfLevelMap[ngIfLevel] += ngIfCounterTmp;\n          }\n          // console.log('ngIfLevelMap2', ngIfLevel, ngIfLevels, ngIfLevelMap);\n          if (LevelMap[level] > 0) {\n            LevelMap[level]--;\n          }\n        }\n\n        //close \"if\", \"for\", \"while\" blocks\n        //while is needed because loop and if can be in same tag\n        while (LevelMap[level] > 0) {\n          FnText += indent(level, 1) + '}\\n';\n          LevelMap[level]--;\n        }\n\n        //clear ng-repeat $index\n        if (ngRepeatLevel === level) {\n          LevelVarMap[level] = 0;\n          while (ngRepeatLevel >=0 && typeof LevelVarMap[--ngRepeatLevel] === 'undefined') {}\n        }\n\n        //reset dota-pass when out of scope\n        if (doTAPass >= level) {\n          doTAPass = void 0;\n        }\n      },\n\n      //close tag\n      closeTag: function(tagName) {\n        level--;\n\n        //just write closing tag back\n        FnText += indent(level) + \"R+='</\" + tagName + \">';\\n\";\n\n        //ngIfCounter for most possible uniqueId generation; don't work with loop inside!\n        if (diffLevel && level === ngIfLevel && ngIfLevelMap[ngIfLevel] >= 0) {\n          // console.log('ngIfLevelMap1', ngIfLevel, ngIfLevels, ngIfLevelMap);\n          if (ngIfLevelMap[ngIfLevel]) {\n            FnText += indent(level, 1) + \"}else{\" +\n              \"R+='<\" + tagName + \" id=\\\"'+N+'.\" + uniqueId + '\" hidden=\"\" ' +\n              (tagName === 'img' || tagName === 'input' || tagName === 'br' || tagName === 'hr' ?\n                '/>' : '></' + tagName + '>')\n              + '\\';' +\n              \"N+=\" + ngIfLevelMap[ngIfLevel] + \";}; \\n\";\n          }\n          //save counter\n          ngIfCounterTmp = ngIfLevelMap[ngIfLevel];\n          //clear counter\n          ngIfLevelMap[ngIfLevel] = void 0;\n          //remove last level\n          ngIfLevel = ngIfLevels[--ngIfLevels.length - 1];\n          //add up to previous level\n          if (ngIfLevel) {\n            ngIfLevelMap[ngIfLevel] += ngIfCounterTmp;\n          }\n          // console.log('ngIfLevelMap2', ngIfLevel, ngIfLevels, ngIfLevelMap);\n          if (LevelMap[level] > 0) {\n            LevelMap[level]--;\n          }\n        }\n\n        // console.log('LevelMap1', LevelMap);\n        //close \"if\", \"for\", \"while\" blocks\n        while (LevelMap[level] > 0) {\n          FnText += indent(level, 1) + '}\\n';\n          LevelMap[level]--;\n        }\n        // console.log('LevelMap2', LevelMap);\n\n        if (diffLevel) {\n          if (level === skipLevel) {\n            // console.log('ngIfLevel', [level, skipLevel, ngRepeatLevel])\n            FnText += indent(level, 1) + 'N=O' + level + '; \\n';\n          }\n          if (level === skipLevel) {\n            skipLevel = void 0;\n          }\n        }\n\n        //clear ng-repeat $index\n        if (ngRepeatLevel === level) {\n          LevelVarMap[level] = 0;\n          while (ngRepeatLevel >=0 && typeof LevelVarMap[--ngRepeatLevel] === 'undefined') {}\n        }\n\n        //add blank node if $watch block return nothing, mostly occur with ng-if\n        if (WatchMap[level]) {\n          FnText += indent(level, 1) +\n            \"R=R||('<\" + tagName + ' id=\"' + idHash[uniqueId + '.' + level] +\n            '\" style=\"display:none\"></' + tagName + '>\\');\\n';\n          WatchMap[level] = 0;\n          FnText += indent(level, 2) + 'return R;}; \\n';\n          FnText += indent(level, 2) + 'R+=W.F(S,F,$attr,X,N); \\n';\n        }\n\n        //reset dota-pass when out of scope\n        if (doTAPass >= level) {\n          doTAPass = void 0;\n        }\n      },\n\n      //text node\n      text: function(text) {\n        //console.log([text]);\n        FnText += indent(level) + ('R+=\\'' + interpolate(text) + '\\';\\n')\n          .replace(/\\+''|''\\+/g,'');\n      },\n\n      //comment node\n      comment: function(data) {\n        if (options.comment !== 0) {\n          //console.log(111,[data]);\n          FnText += indent(level) + \"R+='<\" + escapeSingleQuote(data) + \">';\\n\";\n        }\n      }\n    });\n\n    if (watchDiff) {\n      FnText += indent(0) + 'if(X&&J in doTA.H){doTA.diff' + (diffLevel || '') + '(J,R)}' +\n        'doTA.H[J]=R;\\n';\n    }\n\n    FnText += indent(0) +'return R;\\n';\n\n    //Default Optimization\n    // - concat possible lines for performance\n    FnText = FnText.replace(/;R\\+=/g,'+').replace(/'\\+'/g,'');\n\n    //extra optimization, which might take some more CPU\n    if (options.optimize && !watchDiff) {\n      FnText = FnText.replace(removeUnneededQuotesRegex,'$1$2');\n    }\n\n    //print the whole function if debug\n    if (options.debug) {\n      /**/console.log(FnText);\n    }\n    // console.log(FnText);\n\n    try {\n      //$scope, $filter\n      compiledFn = new Function('S', 'F', '$attr', 'X', FnText);\n      if (Watched) {\n        compiledFn = {W:[], F: compiledFn};\n      }\n    } catch (err) {\n      if (typeof console !== \"undefined\") {\n        /**/console.log(\"doTA compile error:\\n\" + FnText);\n      }\n      throw err;\n    }\n\n    // just for less array usage on heap profiling\n    // but this may trigger GC more\n    FnText = LevelMap = LevelVarMap = VarMap = ngIfLevels = ngIfLevelMap = WatchMap = idHash = void 0;\n    return compiledFn;\n  }\n\n  var compiledHash = {};\n  var lastId = 0;\n\n  function initCompileHash(obj) {\n    for (var x in obj) {\n      compiledHash[x] = obj[x];\n      if (obj[x] > lastId) {\n        lastId = obj[x];\n      }\n    }\n  }\n\n  function getUniqueId(key) {\n    if (key) {\n      if (compiledHash[key]) {\n        return compiledHash[key];\n      } else {\n        compiledHash[key] = lastId;\n        return lastId++;\n      }\n    } else {\n      return lastId++;\n    }\n  }\n\n  var doTAObj = {\n    diff: diffPatchExact,\n    diff2: diffPatchChildren,\n    getId: getUniqueId,\n    initCH: initCompileHash,\n    compile: compileHTML,\n    C: {}, //Cached compiled functions\n    D: {}, //Cached DOM to be used by ngDoTA, needed here to prevent unneccessary rendering\n    H: {} //HashMap for TextDiff\n  };\n\n  //warmup most used functions\n  doTAObj.compile('<div class=\"x {{x}}\" ng-class=\"{x:1}\" ng-repeat=\"x in y\" ng-if=\"x\">x{{x}}</div><!--x-->', {\n    watchDiff: 1, diffLevel: 2});\n\n  return doTAObj;\n})();\n\nif (typeof module !== \"undefined\" && module.exports) {\n  module.exports = doTA;\n//IE8\n} else if (typeof console === \"undefined\") {\n  var noop = function() {};\n  console = {log: noop, time: noop, timeEnd: noop};\n}\n\n/* global angular, doTA */\n(function (angular, document) {'use strict';\n  var msie = document.documentMode;\n  var ie8 = msie <= 8;\n  var textContent = ie8 ? 'innerText' : 'textContent';\n  var listenerName = ie8 ? 'attachEvent' : 'addEventListener';\n  var hiddenDIV;\n  setTimeout(function(){\n    if (document.createElement) {\n      hiddenDIV = document.createElement('div');\n    }\n  },0);\n  var BoolMap = {0: 0, 'false': 0, 1: 1, 'true': 1};\n  function makeBool(attr, defaultValue){\n    return attr in BoolMap ? BoolMap[attr] : attr || defaultValue;\n  }\n\n  function forEachArray(src, iter, ctx) {\n    if (!src) { return; }\n    if (src.forEach) {\n      return src.forEach(iter);\n    }\n    for (var key = 0, length = src.length; key < length; key++) {\n      iter.call(ctx, src[key], key);\n    }\n  }\n\n  //retrieve nested value from object, support a.b or a[b]\n  function resolveObject(path, obj) {\n    if (path.indexOf('.') >= 0 || path.indexOf('[') >= 0) {\n      var chunks = path.replace(/[\\]]$/, '').split(/[.\\[\\]\"']+/g);\n      return chunks.reduce(function (prev, curr) {\n        return prev ? prev[curr] : undefined;\n      }, obj);\n    } else {\n      return obj[path];\n    }\n  }\n\n  //get nested value as assignable fn like $parse.assign\n  function parseObject(path, obj) {\n    if (path.indexOf('.') >= 0 || path.indexOf('[') >= 0) {\n      var chunks = path.replace(/[\\]]$/, '').split(/[.\\[\\]\"']+/g);\n      path = chunks.splice(-1, 1)[0];\n      // console.log('path, last', chunks, path)\n      obj = chunks.reduce(function (prev, curr) {\n        // console.log('parseObject', [prev, curr])\n        if (!prev[curr]) {\n          prev[curr] = {};\n        }\n        return prev[curr];\n      }, obj);\n    }\n    return {\n      assign: function(val) {\n        obj[path] = val;\n      }\n    };\n  }\n\n  // var obj = {};\n  // var parsed = parseObject('name', obj);\n  // parsed.assign('test');\n  // console.log(obj);\n  // parsed = parseObject('three.one', obj);\n  // parsed.assign('haha');\n  // console.log(obj);\n\n  //debounce for events\n  // function debounce(fn, timeout) {\n  //   if (timeout === undefined) {\n  //     timeout = 200;\n  //   }\n  //   var timeoutId;\n  //   var args, thisArgs;\n  //   function debounced() {\n  //     fn.apply(thisArgs, args);\n  //   }\n  //   return function() {\n  //     args = arguments;\n  //     thisArgs = this;\n  //     if (timeoutId) {\n  //       clearTimeout(timeoutId);\n  //     }\n  //     // console.log('debounce: new timer', [timer]);\n  //     timeoutId = setTimeout(debounced, timeout);\n  //   };\n  // }\n\n  //throttle for events\n  function throttle(fn, timeout) {\n    if (timeout === undefined) {\n      timeout = 200;\n    }\n    var timeoutId;\n    var start = +new Date(), now;\n    // console.log('timeout', timeout)\n    var args, thisArgs;\n    function throttled() {\n      fn.apply(thisArgs, args);\n    }\n    return function() {\n      args = arguments;\n      thisArgs = this;\n      now = +new Date();\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n      if (now - start >= timeout) {\n        // console.log(now - start)\n        start = now;\n        throttled();\n        return;\n      }\n      // console.log('throttled: new timer', [timer]);\n      timeoutId = setTimeout(throttled, timeout);\n    };\n  }\n  doTA.throttle = throttle; //export\n\n  //hide and destroy children\n  function destroyChildren(elem) {\n    var child = elem.firstChild, hiddenTags = [];\n    if (child) {\n      child.hidden = 1;\n      hiddenTags.push(child);\n      while (child = child.nextSibling) {\n        child.hidden = 1;\n        hiddenTags.push(child);\n      }\n    }\n    //destroying children block everything\n    // so do it later, since deleting don't have to be synchronous\n    setTimeout(function(){\n      console.time('removeChild');\n      forEachArray(hiddenTags, function(child) {\n        if (child && child.parentNode) {\n          child.parentNode.removeChild(child);\n        }\n      });\n      console.timeEnd('removeChild');\n    })\n  }\n\n  function eventHandlerFn(scope, expr) {\n    return function(evt){\n      if (ie8) {\n        //make $event.target always available\n        evt.target = evt.srcElement || document;\n        evt.returnValue = false;\n        evt.cancelBubble = true;\n      } else {\n        evt.preventDefault();\n        evt.stopPropagation();\n      }\n\n      // if (scope.$evalAsync) {\n        //isedom: disallow, so no $target here\n        scope.$evalAsync(expr, {$event: evt});\n      // } else {\n      //   scope.$event = evt;\n      //   // var locals = {$event: evt};\n      //   var fn = new Function('with(this){' + expr + '}');\n      //   console.log('eventHandlerFn', fn, scope);\n      //   fn.apply(scope);\n      // }\n    };\n  }\n\n  function addEventUnknown(partial, scope, attrs) {\n    if (partial.de) { return; } //only attach events once\n    partial.de = 1;\n    var attributes = partial.attributes, attrName, attrVal;\n    // console.log('attributes', attributes);\n    for(var i = 0, l = attributes.length; i < l; i++) {\n      if (!attributes[i] || !attributes[i].name || !attributes[i].value) { continue; }\n      attrName = attributes[i].name;\n      attrVal = attributes[i].value;\n      if (attrName.substr(0, 3) === 'de-') {\n        //remove attribute, so never bind again\n        partial[listenerName]((ie8 ? 'on' : '') + attrName.substr(3),\n          eventHandlerFn(scope, attrVal));\n        // console.log('event added', uniqueId, attrName);\n      }\n    }\n  }\n\n  //specified events\n  function addEventKnown(partial, scope, attrs) {\n    if (partial.ded) { return; } //only attach events once\n    partial.ded = 1;\n    var attrName, attrVal;\n\n    var events = attrs.events;\n    // console.log('attributes', attributes);\n    for(var i = 0, l = events.length; i < l; i++) {\n      attrName = 'de-' + events[i]\n      attrVal = partial.getAttribute(attrName);\n      // console.log(i, [attrVal, events[i]])\n      if (!attrVal) { continue; }\n      partial[listenerName]((ie8 ? 'on' : '') + events[i],\n        eventHandlerFn(scope, attrVal));\n    }\n  }\n\n  function addEvents(elem, scope, attrs) {\n    //getElementsByClassName is faster than querySelectorAll\n    //http://jsperf.com/queryselectorall-vs-getelementsbytagname/20\n    // console.time('find-nodes:');\n    var elements = ie8 ? elem.querySelectorAll('.de') : elem.getElementsByClassName('de');\n    // console.timeEnd('find-nodes:');\n    if (typeof attrs.event === 'number') {\n      for (var i = 0, l = elements.length; i < l; i++) {\n        addEventUnknown(elements[i], scope, attrs);\n      }\n    } else {\n      attrs.events = attrs.event.split(' ');\n      for (var i = 0, l = elements.length; i < l; i++) {\n        addEventKnown(elements[i], scope, attrs);\n      }\n    }\n  }\n\n  function addNgModels(elem, scope, uniqueId) {\n    forEachArray(elem.querySelectorAll('[dota-model]'), function(partial) {\n      var dotaPass = partial.getAttribute('dota-pass');\n      // console.log('dotaPass', [dotaPass]);\n      if (dotaPass != undefined) { return; } //null or undefined\n\n      var modelName = partial.getAttribute('dota-model');\n\n      //textbox default event is input unless IE8, all others are change event\n      var updateOn = partial.getAttribute('update-on') ||\n        (partial.type !== 'text' || ie8 ? 'change' : 'input');\n      var throttleVal = +partial.getAttribute('throttle') || 100;\n\n      //use checked property for checkbox and radio\n      var bindProp = partial.getAttribute('bind-prop') ||\n        ((partial.type === 'checkbox' || partial.type === 'radio') && 'checked');\n      var curValue = resolveObject(modelName, scope) || '';\n\n      console.log('partial', [partial.tagName, partial.type, curValue]);\n      if (bindProp) {\n        //set true or false on dom properties\n        partial[bindProp] = partial.value === curValue;\n      } else {\n        partial.value = curValue;\n      }\n\n      //bind each events\n      var parsed;\n      forEachArray(updateOn.split(' '), function(evtName){\n        evtName = evtName.trim();\n        partial.addEventListener(evtName, throttle(function(evt) {\n          if (!parsed) {\n            parsed = parseObject(modelName, scope);\n          }\n          evt.preventDefault();\n          evt.stopPropagation();\n\n          // console.log('event', evtName, evt.target, [evt.target[bindProp || 'value']])\n          scope.$applyAsync((function(){\n            if (bindProp) {\n              parsed.assign(bindProp && evt.target[bindProp] ? evt.target.value : undefined);\n            } else {\n              parsed.assign(evt.target.value);\n            }\n          }))\n        }, throttleVal));\n      });\n    });\n  }\n\n  angular.module('doTA', [])\n    .config(['$provide',function(P) {\n      P.factory('doTA', function(){\n        doTA.addEvents = addEvents;\n        doTA.addNgModels = addNgModels;\n        return doTA;\n      });\n    }])\n\n    .directive('dotaRender', ['doTA', '$http', '$filter', '$templateCache', '$compile', '$controller',\n      function(doTA, $http, $filter, $templateCache, $compile, $controller) {\n      var scopes = {}; //scope management\n\n      return {\n        restrict: 'A',\n        priority: 10000,\n        terminal: true,\n        controller: angular.noop,\n        link: angular.noop,\n        compile: function() {\n          var Watchers = [], BindValues = {};\n\n          return function($scope, elem, attrs) {\n            //used attributes, good for minification with closure compiler;\n            var attrCacheDOM = attrs.cacheDom;\n            var attrDoTARender = attrs.dotaRender;\n            var attrScope = attrs.scope;\n            var attrNgController = attrs.ngController;\n            var attrLoose = attrs.loose;\n            var attrEvent = attrs.event;\n            var attrDebug = attrs.debug;\n            var attrWatch = attrs.watch;\n            var attrCompile = attrs.compile;\n            var attrModel = attrs.model;\n            var attrBind = attrs.bind;\n            var attrCompileAll = attrs.compileAll;\n            var attrDoTAOnload = attrs.dotaOnload;\n            var attrDoTAOnloadScope = attrs.dotaOnloadScope;\n            var attrLoaded = attrs.loaded;\n            var attrInline = attrs.inline;\n            var attrWatchDiff = attrs.watchDiff;\n            var origAttrMap = attrs.$attr;\n            var params = {};\n            var NewScope;\n\n            attrs.loose = makeBool(attrLoose, 1); //if set, falsy => ''\n            attrs.optimize = makeBool(attrs.optimize, 0);\n            attrs.comment = makeBool(attrs.comment, 1); //if 0, remove comments\n            attrDebug = attrs.debug = makeBool(attrDebug, 0);\n            attrEvent = attrs.event = makeBool(attrEvent, 1); //ng-click to native click\n            attrWatch = attrs.watch = typeof attrWatch === 'string' ? attrWatch : 0; //Firefox throw error if does not exists\n\n            //to prevent angular binding this\n            if (attrNgController) {\n              elem[0].removeAttribute('ng-controller');\n            }\n\n            if (attrCacheDOM && doTA.D[attrDoTARender]) {\n              // alert( doTA.D[attrDoTARender].innerHTML);\n              console.log('cacheDOM: just moved cached DOM', doTA.D[attrDoTARender]);\n              var cachedElem = msie ? doTA.D[attrDoTARender].cloneNode(true) : doTA.D[attrDoTARender];\n              elem[0].parentNode.replaceChild(cachedElem, elem[0]);\n              return;\n            }\n\n            //attributes on dota-render tags to be accessiable as $attr in templates\n            for (var x in origAttrMap) {\n              var z = origAttrMap[x];\n              //map data-* attributes into origAttrMap (inline text)\n              if (!z.indexOf('data-')) {\n                params[x] = attrs[x];\n              //map scope-* attributes into origAttrMap (first level var from scope)\n              } else if (!z.indexOf('scope-')) {\n                if (attrs[x].indexOf('.') >= 0 || attrs[x].indexOf('[') >= 0) {\n                  params[z.slice(6)] = $scope.$eval(attrs[x]);\n                } else {\n                  params[z.slice(6)] = $scope[attrs[x]];\n                }\n              }\n            }\n\n            //create new scope if scope=1 or ng-controller is specified\n            if (attrScope || attrNgController) {\n              console.log('scope', attrScope, elem, elem.scope());\n\n              //$destroy previously created scope or will leak.\n              if (scopes[attrDoTARender]) {\n                scopes[attrDoTARender].$destroy();\n                // /**/console.log('newScope $destroy', attrDoTARender, NewScope);\n              }\n              NewScope = scopes[attrDoTARender] = $scope.$new();\n              // /**/console.log('newScope created', attrDoTARender, NewScope);\n            } else {\n              NewScope = $scope;\n            }\n\n            //attach ng-controller, and remove attr to prevent angular running again\n            if (attrNgController) {\n              var asPos = attrNgController.indexOf(' as ');\n              if (asPos > 0) {\n                attrNgController = attrNgController.substr(0, asPos).trim();\n              }\n              console.log('new controller', attrNgController);\n              var l = {$scope: NewScope}, controller = $controller(attrNgController, l);\n              //untested controller-as attr or as syntax\n              if (attrs.controllerAs || asPos > 0) {\n                NewScope[attrs.controllerAs || attrNgController.substr(asPos + 4).trim()] = controller;\n              }\n              elem.data('$ngControllerController', controller);\n              elem.children().data('$ngControllerController', controller);\n              console.log('new controller created', attrDoTARender);\n            }\n\n            // watch and re-render the whole template when change\n            if(attrWatch) {\n              console.log(attrDoTARender, 'registering watch for', attrWatch);\n              var oneTimePos = attrWatch.indexOf('::');\n              if (oneTimePos >= 0) {\n                attrWatch = attrWatch.slice(oneTimePos + 2);\n              }\n              var oneTimeExp = NewScope.$watchCollection(attrWatch, function(newVal, oldVal){\n                if(newVal !== undefined && newVal !== oldVal && doTA.C[attrDoTARender]) {\n                  if (oneTimePos >= 0) oneTimeExp();\n                  console.log(attrDoTARender, 'watch before render');\n                  render(doTA.C[attrDoTARender]);\n                  console.log(attrDoTARender, 'watch after render');\n                }\n              });\n            }\n\n            // watch and partially render by diffing. diff-level = 2 may be used to patch children\n            if(attrWatchDiff) {\n              console.log(attrDoTARender, 'registering diff watch for', attrWatchDiff);\n              NewScope.$watchCollection(attrWatchDiff, function(newVal, oldVal){\n                if(newVal !== oldVal && doTA.C[attrDoTARender]) {\n                  console.log(attrDoTARender, 'diff watch before render');\n                  render(doTA.C[attrDoTARender], true);\n                  console.log(attrDoTARender, 'diff watch after render');\n                }\n              });\n            }\n\n            // run the loader\n            loader();\n\n            ////////////////////////////////////////////////////////////////////////////\n            // cache-dom for static html, $scope will not be triggered\n            ////////////////////////////////////////////////////////////////////////////\n            function cacheDOM(){\n              // console.log('cacheDOM()', attrs)\n              $scope.$on(\"$destroy\", function(){\n                console.log('$destroy', elem);\n                // alert(['$destroy', elem[0], hiddenDIV]);\n                if (hiddenDIV) {\n                  doTA.D[attrDoTARender] = elem[0];\n                  hiddenDIV.appendChild(elem[0]);\n                }\n              });\n            }\n\n            ////////////////////////////////////////////////////////////////////////////\n            // doTA.compile and return compiledFn\n            ////////////////////////////////////////////////////////////////////////////\n            function compile(template) {\n              if(attrDebug) {\n                console.log(attrDoTARender + ':' + template);\n              }\n\n              console.log(attrDoTARender,'before compile');\n              //compile the template html text to function like doT does\n              try {\n                console.time('compile:' + attrDoTARender);\n                var compiledFn = doTA.compile(template, attrs);\n                console.timeEnd('compile:'  + attrDoTARender);\n                console.log(attrDoTARender,'after compile(no-cache)');\n              } catch (x) {\n                /**/console.log('compile error', attrs, template);\n                throw x;\n              }\n\n              //compiled func into cache for later use\n              if (attrDoTARender) {\n                doTA.C[attrDoTARender] = compiledFn;\n              }\n\n              return compiledFn;\n            }\n\n            ////////////////////////////////////////////////////////////////////////////\n            // attach ng-bind\n            ////////////////////////////////////////////////////////////////////////////\n            function addNgBind(rawElem, scope, attrDoTARender) {\n              //ToDo: check Watchers scope\n              while (Watchers.length) {\n                Watchers.pop()();\n              }\n              forEachArray(rawElem.querySelectorAll('[dota-bind]'), function(partial) {\n                //override ng-bind\n                var bindExpr = partial.getAttribute('dota-bind');\n                var oneTimePos = bindExpr.indexOf('::');\n                if (oneTimePos >= 0) {\n                  bindExpr = bindExpr.slice(oneTimePos + 2);\n                }\n\n                if (BindValues[bindExpr]) {\n                  partial.innerHTML = BindValues[bindExpr];\n                }\n                var oneTimeExp = scope.$watchCollection(bindExpr, function(newVal, oldVal){\n                  if (newVal && oneTimePos >= 0) { oneTimeExp(); }\n                  console.log(attrDoTARender, 'watch before bindExpr', [newVal, oldVal]);\n                  partial[textContent] = BindValues[bindExpr] = newVal || '';\n                  console.log(attrDoTARender, 'watch after render');\n                });\n                Watchers.push(oneTimeExp);\n              });\n            }\n\n            ////////////////////////////////////////////////////////////////////////////\n            // attach ng-model, events, ng-bind, and $compile\n            ////////////////////////////////////////////////////////////////////////////\n            function attachEventsAndCompile(rawElem, scope) {\n\n              if (attrModel) {\n                console.time('ngModel:' + attrDoTARender);\n                addNgModels(rawElem, scope, attrDoTARender);\n                console.timeEnd('ngModel:' + attrDoTARender);\n              }\n\n              //attach events before replacing\n              if (attrEvent) {\n                console.time('ng-events:' + attrDoTARender);\n                addEvents(rawElem, scope, attrs);\n                console.timeEnd('ng-events:' + attrDoTARender);\n              }\n\n              //ng-bind\n              if (attrBind) {\n                console.time('ngBind:' + attrDoTARender);\n                addNgBind(rawElem, scope, attrDoTARender);\n                console.timeEnd('ngBind:' + attrDoTARender);\n              }\n\n              //$compile html if you need ng-model or ng-something\n              if (attrCompile){\n                //partially compile each dota-pass and its childs,\n                // not sure this is suitable if you have so many dota-passes\n                console.time('compile:' + attrDoTARender);\n                forEachArray(rawElem.querySelectorAll('[dota-pass]'), function(partial){\n                  $compile(partial)(scope);\n                });\n                console.timeEnd('compile:' + attrDoTARender);\n                console.log(attrDoTARender,'after $compile partial');\n\n              } else if (attrCompileAll){\n                //compile child nodes\n                console.time('compile-all:' + attrDoTARender);\n                $compile(rawElem.contentDocument || rawElem.childNodes)(scope);\n                console.timeEnd('compile-all:' + attrDoTARender);\n                console.log(attrDoTARender,'after $compile all');\n              }\n            }\n\n            ////////////////////////////////////////////////////////////////////////////\n            // render the template, cache-dom, run onload scripts, add dynamic watches\n            ////////////////////////////////////////////////////////////////////////////\n            function render(func, patch) {\n\n              //unless prerender\n              if (func) {\n                //trigger destroying children\n                if (!patch && elem[0].firstChild) {\n                  destroyChildren(elem[0]);\n                }\n\n                console.log(attrDoTARender, 'before render', patch);\n                //execute render function against scope, $filter, etc.\n                try {\n                  console.time('render:' + attrDoTARender);\n                  var v = func.F ? func.F(NewScope, $filter, params, patch) : func(NewScope, $filter, params, patch);\n                  console.timeEnd('render:' + attrDoTARender);\n                  console.log(attrDoTARender,'after render', patch);\n                } catch (x) {\n                  /**/console.log('render error', func);\n                  throw x;\n                }\n\n                if(attrDebug) {\n                  /* */console.log(attrDoTARender, v);\n                  // console.log(attrDoTARender, (func.F || func).toString());\n                }\n\n                // console.log('patch?', [patch]);\n                if (patch) {\n                  attachEventsAndCompile(elem[0], NewScope);\n                  return;\n                }\n\n                //if node has some child, use appendChild\n                if (elem[0].firstChild) {\n                  console.time('appendChild:' + attrDoTARender);\n                  var newNode = document.createElement('div'), firstChild;\n                  newNode.innerHTML = v;\n\n                  //if needed, attach events and $compile\n                  attachEventsAndCompile(newNode, NewScope);\n\n                  //move child from temp nodes\n                  while (firstChild = newNode.firstChild) {\n                    elem[0].appendChild(firstChild);\n                  }\n                  console.timeEnd('appendChild:' + attrDoTARender);\n                  console.log(attrDoTARender, 'after appendChild');\n\n                //if node is blank, use innerHTML\n                } else {\n                  console.time('innerHTML:' + attrDoTARender);\n                  elem[0].innerHTML = v;\n                  console.timeEnd('innerHTML:' + attrDoTARender);\n                  console.log(attrDoTARender, 'after innerHTML');\n\n                  //if needed, attach events and $compile\n                  attachEventsAndCompile(elem[0], NewScope);\n                }\n\n              //attach client side to prerender context\n              } else {\n                attachEventsAndCompile(elem[0], NewScope);\n              }\n\n              //execute raw functions, like jQuery\n              if(attrDoTAOnload){\n                setTimeout(function(){\n                  var onLoadFn = new Function(attrDoTAOnload);\n                  onLoadFn.apply(elem[0]);\n                  console.log(attrDoTARender,'after eval');\n                });\n              }\n\n              //execute scope functions\n              if(attrDoTAOnloadScope) {\n                setTimeout(function() {\n                  NewScope.$evalAsync(attrDoTAOnloadScope);\n                  console.log(attrDoTARender, 'after scope $evalAsync scheduled');\n                });\n              }\n\n              if (attrCacheDOM) {\n                cacheDOM();\n              }\n\n              //you can now hide raw html before rendering done\n              // with loaded=false attribute and following css\n              /*\n              [dota-render][loaded]:not([loaded=true]) {\n                display: none;\n              }\n              */\n              if (attrLoaded) {\n                elem.attr(\"loaded\",true);\n              }\n\n              //this watch may be dynamically add or remove\n              if (func && func.W) {\n                console.log('func.W watch', attrDoTARender, func.W);\n                var scopes = {}, watches = {};\n                for(var i = 0; i < func.W.length; i++) {\n                  var w = func.W[i];\n                  // console.log('watch', w);\n\n                  watches[w.I] = NewScope.$watchCollection(w.W, (function(w) {\n                    return function(newVal, oldVal){\n                      console.log('$watch trigger', [newVal, oldVal]);\n                      if (newVal === oldVal && !newVal) { return; }\n                      console.log(attrDoTARender, w.W, 'partial watch before render');\n                      var oldTag = document.getElementById(w.I);\n                      if (!oldTag) { return console.log('tag not found'); }\n\n                      //we don't need new scope here\n                      var content = w.F(NewScope, $filter, params, null, w.N);\n                      if (!content) { return console.log('no contents'); }\n                      console.log('watch new content', content);\n                      var newTag = angular.element(content);\n\n                      //compile only if specified\n                      if (w.C) {\n                        //scope management\n                        if (scopes[w.I]) {\n                          scopes[w.I].$destroy();\n                        }\n                        scopes[w.I] = NewScope.$new();\n                      }\n\n                      attachEventsAndCompile(newTag[0], scopes[w.I] || NewScope);\n\n                      angular.element(oldTag).replaceWith(newTag);\n\n                      console.log(attrDoTARender, w.W, 'partial watch content written');\n                      //unregister watch if wait once\n                      if (w.O) {\n                        console.log(attrDoTARender, w.W, 'partial watch unregistered');\n                        watches[w.I]();\n                      }\n                      console.log(attrDoTARender, w.W, 'partial watch after render');\n                    };\n                  })(w));\n                }\n              }\n            }\n\n            function loader(){\n              if(doTA.C[attrDoTARender]){\n                console.log(attrDoTARender,'get compile function from cache');\n                //watch need to redraw, also inline, because inline always hasChildNodes\n                if (elem[0].hasChildNodes() && !attrInline) {\n                  console.log('hasChildNodes', attrDoTARender);\n                  render();\n                } else {\n                  render(doTA.C[attrDoTARender]);\n                }\n              } else if (attrInline) {\n                // render inline by loading inner html tags,\n                // html entities encoding sometimes need for htmlparser here or you may use htmlparser2 (untested)\n                console.log(attrDoTARender,'before get innerHTML');\n                var v = elem[0].innerHTML;\n                console.log(attrDoTARender,'after get innerHTML');\n                render(compile(v, attrs));\n              } else if (attrDoTARender) { //load real template\n                console.log('before $http', attrDoTARender);\n                //server side rendering or miss to use inline attrs?\n                if (elem[0].hasChildNodes()) {\n                  console.log('hasChildNodes', attrDoTARender);\n                  render();\n                } else {\n                  $http.get(attrDoTARender, {cache: $templateCache}).success(function (v) {\n                    console.log('after $http response', attrDoTARender);\n                    render(compile(v, attrs));\n                  });\n                }\n              }\n            }\n\n            //////////////////////////////////////////////////\n\n          };\n        }\n      };\n    }])\n    .directive('dotaInclude', ['$http', '$templateCache', '$compile', function($http, $templateCache, $compile) {\n      return {\n        restrict: 'A',\n        priority: 10000,\n        terminal: true,\n        compile: function() {\n          return function(scope, elem, attrs) {\n            var attrCompile = makeBool(attrs.compile, 1);\n\n            console.log('dotaInclude', attrs.dotaInclude);\n            $http.get(attrs.dotaInclude, {cache: $templateCache}).success(function (data) {\n              elem.html(data);\n              if (attrCompile !== 0) {\n                $compile(elem.contents())(scope);\n              }\n            });\n          };\n        }\n      };\n    }])\n    .directive('dotaTemplate', ['$http', '$templateCache', '$compile', function($http, $templateCache, $compile) {\n      return {\n        restrict: 'A',\n        priority: 10000,\n        terminal: true,\n        compile: function() {\n          return function(scope, elem, attrs) {\n            var attrCompile = makeBool(attrs.compile, 1);\n\n            scope.$watch(attrs.dotaTemplate, function(newVal, oldVal) {\n              if (newVal) {\n                console.log('dotaTemplate', newVal);\n                $http.get(newVal, {cache: $templateCache}).success(function (data) {\n                  elem.html(data);\n                  if (attrCompile !== 0) {\n                    console.log('dotaTemplate $compile', newVal, data);\n                    $compile(elem.contents())(scope);\n                  }\n                });\n              }\n            });\n          };\n        }\n      };\n    }])\n    .factory('dotaHttp', ['$compile', '$http', '$templateCache', '$filter', 'doTA',\n      function($compile, $http, $templateCache, $filter, doTA) {\n      return function (name, scope, callback, options){\n        options = options || {};\n        options.loose = 1;\n        // options.debug = 1;\n        // /**/console.log('options')\n\n        if (doTA.C[name]) {\n          // /**/console.log('dotaHttp doTA cache', name);\n          callback(doTA.C[name](scope, $filter));\n        } else {\n          // /**/console.log('dotaHttp $http', name);\n          $http.get(name, {cache: $templateCache}).success(function(data) {\n            // /**/console.log('dotaHttp response', data);\n            doTA.C[name] = doTA.compile(data, options);\n            callback(doTA.C[name](scope, $filter));\n          });\n        }\n      };\n    }]);\n\n})(window.angular, window.document);\n"],"sourceRoot":"/source/"}